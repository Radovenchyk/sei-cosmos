
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>keeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/genesis.go (100.0%)</option>
				
				<option value="file1">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/grpc_query.go (100.0%)</option>
				
				<option value="file2">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/keeper.go (93.9%)</option>
				
				<option value="file3">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/msg_server.go (100.0%)</option>
				
				<option value="file4">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/options.go (100.0%)</option>
				
				<option value="file5">github.com/cosmos/cosmos-sdk/x/accesscontrol/keeper/params.go (100.0%)</option>
				
				<option value="file6">github.com/cosmos/cosmos-sdk/x/accesscontrol/migrations/v1_to_v2.go (90.9%)</option>
				
				<option value="file7">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/access_operations.go (0.0%)</option>
				
				<option value="file8">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/codec.go (100.0%)</option>
				
				<option value="file9">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/genesis.go (26.7%)</option>
				
				<option value="file10">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/genesis.pb.go (2.2%)</option>
				
				<option value="file11">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/gov.go (14.8%)</option>
				
				<option value="file12">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/gov.pb.go (0.6%)</option>
				
				<option value="file13">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/graph.go (81.0%)</option>
				
				<option value="file14">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/keys.go (25.0%)</option>
				
				<option value="file15">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/message_dependency_mapping.go (56.2%)</option>
				
				<option value="file16">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/msgs.go (0.0%)</option>
				
				<option value="file17">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/params.go (71.4%)</option>
				
				<option value="file18">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/query.pb.go (1.1%)</option>
				
				<option value="file19">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/query.pb.gw.go (0.0%)</option>
				
				<option value="file20">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/tx.pb.go (2.8%)</option>
				
				<option value="file21">github.com/cosmos/cosmos-sdk/x/accesscontrol/types/wasm.go (91.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package keeper

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"
)

func (k Keeper) InitGenesis(ctx sdk.Context, genState types.GenesisState) <span class="cov8" title="1">{
        k.SetParams(ctx, genState.Params)
        for _, resourceDependencyMapping := range genState.GetMessageDependencyMapping() </span><span class="cov8" title="1">{
                err := k.SetResourceDependencyMapping(ctx, resourceDependencyMapping)
                if err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Errorf("invalid MessageDependencyMapping %s", err))</span>
                }
        }
        <span class="cov8" title="1">for _, wasmDependencyMapping := range genState.GetWasmDependencyMappings() </span><span class="cov8" title="1">{
                err := k.SetWasmDependencyMapping(ctx, wasmDependencyMapping)
                if err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Errorf("invalid WasmDependencyMapping %s", err))</span>
                }

        }
}

func (k Keeper) ExportGenesis(ctx sdk.Context) *types.GenesisState <span class="cov8" title="1">{
        resourceDependencyMappings := []acltypes.MessageDependencyMapping{}
        k.IterateResourceKeys(ctx, func(dependencyMapping acltypes.MessageDependencyMapping) (stop bool) </span><span class="cov8" title="1">{
                resourceDependencyMappings = append(resourceDependencyMappings, dependencyMapping)
                return false
        }</span>)
        <span class="cov8" title="1">wasmDependencyMappings := []acltypes.WasmDependencyMapping{}
        k.IterateWasmDependencies(ctx, func(dependencyMapping acltypes.WasmDependencyMapping) (stop bool) </span><span class="cov8" title="1">{
                wasmDependencyMappings = append(wasmDependencyMappings, dependencyMapping)
                return false
        }</span>)
        <span class="cov8" title="1">return &amp;types.GenesisState{
                Params:                   k.GetParams(ctx),
                MessageDependencyMapping: resourceDependencyMappings,
                WasmDependencyMappings:   wasmDependencyMappings,
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"
)

var _ types.QueryServer = Keeper{}

func (k Keeper) Params(ctx context.Context, req *types.QueryParamsRequest) (*types.QueryParamsResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        params := k.GetParams(sdkCtx)

        return &amp;types.QueryParamsResponse{Params: params}, nil
}</span>

func (k Keeper) ResourceDependencyMappingFromMessageKey(ctx context.Context, req *types.ResourceDependencyMappingFromMessageKeyRequest) (*types.ResourceDependencyMappingFromMessageKeyResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        resourceDependency := k.GetResourceDependencyMapping(sdkCtx, types.MessageKey(req.GetMessageKey()))
        return &amp;types.ResourceDependencyMappingFromMessageKeyResponse{MessageDependencyMapping: resourceDependency}, nil
}</span>

func (k Keeper) WasmDependencyMapping(ctx context.Context, req *types.WasmDependencyMappingRequest) (*types.WasmDependencyMappingResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        address, err := sdk.AccAddressFromBech32(req.ContractAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wasmDependency, err := k.GetRawWasmDependencyMapping(sdkCtx, address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;types.WasmDependencyMappingResponse{WasmDependencyMapping: *wasmDependency}, nil</span>
}

func (k Keeper) ListResourceDependencyMapping(ctx context.Context, req *types.ListResourceDependencyMappingRequest) (*types.ListResourceDependencyMappingResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        resourceDependencyMappings := []acltypes.MessageDependencyMapping{}
        k.IterateResourceKeys(sdkCtx, func(dependencyMapping acltypes.MessageDependencyMapping) (stop bool) </span><span class="cov8" title="1">{
                resourceDependencyMappings = append(resourceDependencyMappings, dependencyMapping)
                return false
        }</span>)

        <span class="cov8" title="1">return &amp;types.ListResourceDependencyMappingResponse{MessageDependencyMappingList: resourceDependencyMappings}, nil</span>
}

func (k Keeper) ListWasmDependencyMapping(ctx context.Context, req *types.ListWasmDependencyMappingRequest) (*types.ListWasmDependencyMappingResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        wasmDependencyMappings := []acltypes.WasmDependencyMapping{}
        k.IterateWasmDependencies(sdkCtx, func(dependencyMapping acltypes.WasmDependencyMapping) (stop bool) </span><span class="cov8" title="1">{
                wasmDependencyMappings = append(wasmDependencyMappings, dependencyMapping)
                return false
        }</span>)

        <span class="cov8" title="1">return &amp;types.ListWasmDependencyMappingResponse{WasmDependencyMappingList: wasmDependencyMappings}, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package keeper

import (
        "encoding/hex"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/armon/go-metrics"
        "github.com/savaki/jq"
        "github.com/yourbasic/graph"

        "github.com/cosmos/cosmos-sdk/codec"
        "github.com/cosmos/cosmos-sdk/telemetry"
        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/cosmos/cosmos-sdk/types/address"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"
        authkeeper "github.com/cosmos/cosmos-sdk/x/auth/keeper"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
)

// Option is an extension point to instantiate keeper with non default values
type Option interface {
        Apply(*Keeper)
}

type MessageDependencyGenerator func(keeper Keeper, ctx sdk.Context, msg sdk.Msg) ([]acltypes.AccessOperation, error)

type DependencyGeneratorMap map[types.MessageKey]MessageDependencyGenerator

type (
        Keeper struct {
                cdc                              codec.BinaryCodec
                storeKey                         sdk.StoreKey
                paramSpace                       paramtypes.Subspace
                MessageDependencyGeneratorMapper DependencyGeneratorMap
                AccountKeeper                    authkeeper.AccountKeeper
                StakingKeeper                    stakingkeeper.Keeper
        }
)

var ErrWasmDependencyMappingNotFound = fmt.Errorf("wasm dependency mapping not found")

func NewKeeper(
        cdc codec.Codec,
        storeKey sdk.StoreKey,
        paramSpace paramtypes.Subspace,
        ak authkeeper.AccountKeeper,
        sk stakingkeeper.Keeper,
        opts ...Option,
) Keeper <span class="cov8" title="1">{
        if !paramSpace.HasKeyTable() </span><span class="cov8" title="1">{
                paramSpace = paramSpace.WithKeyTable(types.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">keeper := &amp;Keeper{
                cdc:                              cdc,
                storeKey:                         storeKey,
                paramSpace:                       paramSpace,
                MessageDependencyGeneratorMapper: DefaultMessageDependencyGenerator(),
                AccountKeeper:                    ak,
                StakingKeeper:                    sk,
        }

        for _, o := range opts </span><span class="cov8" title="1">{
                o.Apply(keeper)
        }</span>

        <span class="cov8" title="1">return *keeper</span>
}

func (k Keeper) GetResourceDependencyMapping(ctx sdk.Context, messageKey types.MessageKey) acltypes.MessageDependencyMapping <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        depMapping := store.Get(types.GetResourceDependencyKey(messageKey))
        if depMapping == nil </span><span class="cov8" title="1">{
                // If the storage key doesn't exist in the mapping then assume synchronous processing
                return types.SynchronousMessageDependencyMapping(messageKey)
        }</span>

        <span class="cov8" title="1">dependencyMapping := acltypes.MessageDependencyMapping{}
        k.cdc.MustUnmarshal(depMapping, &amp;dependencyMapping)
        return dependencyMapping</span>
}

func (k Keeper) SetResourceDependencyMapping(
        ctx sdk.Context,
        dependencyMapping acltypes.MessageDependencyMapping,
) error <span class="cov8" title="1">{
        err := types.ValidateMessageDependencyMapping(dependencyMapping)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        b := k.cdc.MustMarshal(&amp;dependencyMapping)
        resourceKey := types.GetResourceDependencyKey(types.MessageKey(dependencyMapping.GetMessageKey()))
        store.Set(resourceKey, b)
        return nil</span>
}

func (k Keeper) IterateResourceKeys(ctx sdk.Context, handler func(dependencyMapping acltypes.MessageDependencyMapping) (stop bool)) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        iter := sdk.KVStorePrefixIterator(store, types.GetResourceDependencyMappingKey())
        defer iter.Close()
        for ; iter.Valid(); iter.Next() </span><span class="cov8" title="1">{
                dependencyMapping := acltypes.MessageDependencyMapping{}
                k.cdc.MustUnmarshal(iter.Value(), &amp;dependencyMapping)
                if handler(dependencyMapping) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

func (k Keeper) SetDependencyMappingDynamicFlag(ctx sdk.Context, messageKey types.MessageKey, enabled bool) error <span class="cov8" title="1">{
        dependencyMapping := k.GetResourceDependencyMapping(ctx, messageKey)
        dependencyMapping.DynamicEnabled = enabled
        return k.SetResourceDependencyMapping(ctx, dependencyMapping)
}</span>

type ContractReferenceLookupMap map[string]struct{}

func (k Keeper) GetRawWasmDependencyMapping(ctx sdk.Context, contractAddress sdk.AccAddress) (*acltypes.WasmDependencyMapping, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        b := store.Get(types.GetWasmContractAddressKey(contractAddress))
        if b == nil </span><span class="cov8" title="1">{
                return nil, sdkerrors.ErrKeyNotFound
        }</span>
        <span class="cov8" title="1">dependencyMapping := acltypes.WasmDependencyMapping{}
        if err := k.cdc.Unmarshal(b, &amp;dependencyMapping); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;dependencyMapping, nil</span>
}

func GetCircularDependencyIdentifier(contractAddr sdk.AccAddress, msgInfo *types.WasmMessageInfo) string <span class="cov8" title="1">{
        separator := ";"
        identifier := contractAddr.String() + separator + msgInfo.MessageType.String() + separator + msgInfo.MessageName
        return identifier
}</span>

func FilterReadOnlyAccessOps(accessOps []*acltypes.WasmAccessOperation) []*acltypes.WasmAccessOperation <span class="cov8" title="1">{
        filteredOps := []*acltypes.WasmAccessOperation{}
        for _, accessOp := range accessOps </span><span class="cov8" title="1">{
                if accessOp.Operation.AccessType != acltypes.AccessType_WRITE </span><span class="cov8" title="1">{
                        // if access type is UNKNOWN, convert it to READ so it becomes non blocking since KNOW queries can't perform writes
                        if accessOp.Operation.AccessType == acltypes.AccessType_UNKNOWN </span><span class="cov8" title="1">{
                                accessOp.Operation.AccessType = acltypes.AccessType_READ
                        }</span>
                        <span class="cov8" title="1">filteredOps = append(filteredOps, accessOp)</span>
                }
        }
        <span class="cov8" title="1">return filteredOps</span>
}

func (k Keeper) GetWasmDependencyAccessOps(ctx sdk.Context, contractAddress sdk.AccAddress, senderBech string, msgInfo *types.WasmMessageInfo, circularDepLookup ContractReferenceLookupMap) ([]acltypes.AccessOperation, error) <span class="cov8" title="1">{
        uniqueIdentifier := GetCircularDependencyIdentifier(contractAddress, msgInfo)
        if _, ok := circularDepLookup[uniqueIdentifier]; ok </span><span class="cov8" title="1">{
                // we've already seen this identifier, we should simply return synchronous access Ops
                ctx.Logger().Error("Circular dependency encountered, using synchronous access ops instead")
                return types.SynchronousAccessOps(), nil
        }</span>
        // add to our lookup so we know we've seen this identifier
        <span class="cov8" title="1">circularDepLookup[uniqueIdentifier] = struct{}{}

        dependencyMapping, err := k.GetRawWasmDependencyMapping(ctx, contractAddress)
        if err != nil </span><span class="cov8" title="1">{
                if err == sdkerrors.ErrKeyNotFound </span><span class="cov8" title="1">{
                        return types.SynchronousAccessOps(), nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">accessOps := dependencyMapping.BaseAccessOps
        if msgInfo.MessageType == acltypes.WasmMessageSubtype_QUERY </span><span class="cov8" title="1">{
                // If we have a query, filter out any WRITES
                accessOps = FilterReadOnlyAccessOps(accessOps)
        }</span>
        <span class="cov8" title="1">specificAccessOpsMapping := []*acltypes.WasmAccessOperations{}
        if msgInfo.MessageType == acltypes.WasmMessageSubtype_EXECUTE &amp;&amp; len(dependencyMapping.ExecuteAccessOps) &gt; 0 </span><span class="cov8" title="1">{
                specificAccessOpsMapping = dependencyMapping.ExecuteAccessOps
        }</span> else<span class="cov8" title="1"> if msgInfo.MessageType == acltypes.WasmMessageSubtype_QUERY &amp;&amp; len(dependencyMapping.QueryAccessOps) &gt; 0 </span><span class="cov8" title="1">{
                specificAccessOpsMapping = dependencyMapping.QueryAccessOps
        }</span>

        <span class="cov8" title="1">for _, specificAccessOps := range specificAccessOpsMapping </span><span class="cov8" title="1">{
                if specificAccessOps.MessageName == msgInfo.MessageName </span><span class="cov8" title="1">{
                        accessOps = append(accessOps, specificAccessOps.WasmOperations...)
                        break</span>
                }
        }

        <span class="cov8" title="1">selectedAccessOps, err := k.BuildSelectorOps(ctx, contractAddress, accessOps, senderBech, msgInfo, circularDepLookup)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // imports base contract references
        <span class="cov8" title="1">contractRefs := dependencyMapping.BaseContractReferences
        // add the specific execute or query contract references based on message type + name
        specificContractRefs := []*acltypes.WasmContractReferences{}
        if msgInfo.MessageType == acltypes.WasmMessageSubtype_EXECUTE &amp;&amp; len(dependencyMapping.ExecuteContractReferences) &gt; 0 </span><span class="cov8" title="1">{
                specificContractRefs = dependencyMapping.ExecuteContractReferences
        }</span> else<span class="cov8" title="1"> if msgInfo.MessageType == acltypes.WasmMessageSubtype_QUERY &amp;&amp; len(dependencyMapping.QueryContractReferences) &gt; 0 </span><span class="cov8" title="1">{
                specificContractRefs = dependencyMapping.QueryContractReferences
        }</span>
        <span class="cov8" title="1">for _, specificContractRef := range specificContractRefs </span><span class="cov8" title="1">{
                if specificContractRef.MessageName == msgInfo.MessageName </span><span class="cov8" title="1">{
                        contractRefs = append(contractRefs, specificContractRef.ContractReferences...)
                        break</span>
                }
        }
        <span class="cov8" title="1">importedAccessOps, err := k.ImportContractReferences(ctx, contractAddress, contractRefs, senderBech, msgInfo, circularDepLookup)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // combine the access ops to get the definitive list of access ops for the contract
        <span class="cov8" title="1">selectedAccessOps.Merge(importedAccessOps)

        return selectedAccessOps.ToSlice(), nil</span>
}

func ParseContractReferenceAddress(maybeContractAddress string, sender string, msgInfo *types.WasmMessageInfo) string <span class="cov8" title="1">{
        // sender in case the use case is expected to be one contract calling another expecting a separate call
        const reservedSender = "_sender"
        if maybeContractAddress == reservedSender </span><span class="cov8" title="1">{
                return sender
        }</span>
        // parse the jq instruction from the template - if we can't then assume that its ACTUALLY an address
        // doesn't actually return any errors, just returns nil
        <span class="cov8" title="1">op, _ := jq.Parse(maybeContractAddress)

        // retrieve the appropriate item from the original msg
        data, err := op.Apply(msgInfo.MessageFullBody)
        // if we do have a jq selector but it doesn't apply properly, return maybeContractAddress
        if err != nil </span><span class="cov8" title="1">{
                return maybeContractAddress
        }</span>
        // if we parse it properly convert to string and return
        <span class="cov8" title="1">var newValBytes string
        err = json.Unmarshal(data, &amp;newValBytes)
        if err != nil </span><span class="cov8" title="1">{
                return maybeContractAddress
        }</span>
        <span class="cov8" title="1">return newValBytes</span>
}

func (k Keeper) ImportContractReferences(
        ctx sdk.Context,
        contractAddr sdk.AccAddress,
        contractReferences []*acltypes.WasmContractReference,
        senderBech string,
        msgInfo *types.WasmMessageInfo,
        circularDepLookup ContractReferenceLookupMap,
) (*types.AccessOperationSet, error) <span class="cov8" title="1">{
        importedAccessOps := types.NewEmptyAccessOperationSet()

        jsonTranslator := types.NewWasmMessageTranslator(senderBech, contractAddr.String(), msgInfo)

        // msgInfo can't be nil, it will panic
        if msgInfo == nil </span><span class="cov8" title="1">{
                return nil, sdkerrors.Wrap(types.ErrInvalidMsgInfo, "msgInfo cannot be nil")
        }</span>

        <span class="cov8" title="1">for _, contractReference := range contractReferences </span><span class="cov8" title="1">{
                parsedContractReferenceAddress := ParseContractReferenceAddress(contractReference.ContractAddress, senderBech, msgInfo)
                // if parsing failed and contractAddress is invalid, this step will error and indicate invalid address
                importContractAddress, err := sdk.AccAddressFromBech32(parsedContractReferenceAddress)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">newJson, err := jsonTranslator.TranslateMessageBody([]byte(contractReference.JsonTranslationTemplate))
                if err != nil </span><span class="cov8" title="1">{
                        // if there's a problem translating, log it and then pass in empty json
                        ctx.Logger().Error("Error translating JSON body", err)
                        newJson = []byte(fmt.Sprintf("{\"%s\":{}}", contractReference.MessageName))
                }</span>
                <span class="cov8" title="1">var msgInfo *types.WasmMessageInfo
                if contractReference.MessageType == acltypes.WasmMessageSubtype_EXECUTE </span><span class="cov8" title="1">{
                        msgInfo, err = types.NewExecuteMessageInfo(newJson)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> if contractReference.MessageType == acltypes.WasmMessageSubtype_QUERY </span><span class="cov8" title="1">{
                        msgInfo, err = types.NewQueryMessageInfo(newJson)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
                // We use this to import the dependencies from another contract address
                <span class="cov8" title="1">wasmDeps, err := k.GetWasmDependencyAccessOps(ctx, importContractAddress, contractAddr.String(), msgInfo, circularDepLookup)

                if err != nil </span><span class="cov8" title="1">{
                        // if we have an error fetching the dependency mapping or the mapping is disabled,
                        // we want to return the error and the fallback behavior can be defined in the caller function
                        // recommended fallback behavior is to use synchronous wasm access ops
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        // if we did get deps properly and they are enabled, now we want to add them to our access operations
                        importedAccessOps.AddMultiple(wasmDeps)
                }</span>
        }
        // if we imported all relevant contract references properly, we can return the access ops generated
        <span class="cov8" title="1">return importedAccessOps, nil</span>
}

func (k Keeper) BuildSelectorOps(ctx sdk.Context, contractAddr sdk.AccAddress, accessOps []*acltypes.WasmAccessOperation, senderBech string, msgInfo *types.WasmMessageInfo, circularDepLookup ContractReferenceLookupMap) (*types.AccessOperationSet, error) <span class="cov8" title="1">{
        selectedAccessOps := types.NewEmptyAccessOperationSet()
        // when we build selector ops here, we want to generate "*" if the proper fields aren't present
        // if size of circular dep map &gt; 1 then it means we're in a contract reference
        // as a result, if the selector doesn't match properly, we need to conservatively assume "*" for the identifier
        withinContractReference := len(circularDepLookup) &gt; 1
        for _, opWithSelector := range accessOps </span><span class="cov8" title="1">{
        selectorSwitch:
                switch opWithSelector.SelectorType </span>{
                case acltypes.AccessOperationSelectorType_JQ:<span class="cov8" title="1">
                        op, err := jq.Parse(opWithSelector.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">data, err := op.Apply(msgInfo.MessageFullBody)
                        if err != nil </span><span class="cov8" title="1">{
                                if withinContractReference </span><span class="cov0" title="0">{
                                        opWithSelector.Operation.IdentifierTemplate = "*"
                                        break selectorSwitch</span>
                                }
                                // if the operation is not applicable to the message, skip it
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">trimmedData := strings.Trim(string(data), "\"") // we need to trim the quotes around the string
                        opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString([]byte(trimmedData)),
                        )</span>
                case acltypes.AccessOperationSelectorType_JQ_BECH32_ADDRESS:<span class="cov8" title="1">
                        op, err := jq.Parse(opWithSelector.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">data, err := op.Apply(msgInfo.MessageFullBody)
                        if err != nil </span><span class="cov8" title="1">{
                                if withinContractReference </span><span class="cov0" title="0">{
                                        opWithSelector.Operation.IdentifierTemplate = "*"
                                        break selectorSwitch</span>
                                }
                                // if the operation is not applicable to the message, skip it
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">bech32Addr := strings.Trim(string(data), "\"") // we need to trim the quotes around the string
                        // we expect a bech32 prefixed address, so lets convert to account address
                        accAddr, err := sdk.AccAddressFromBech32(bech32Addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString(accAddr),
                        )</span>
                case acltypes.AccessOperationSelectorType_JQ_LENGTH_PREFIXED_ADDRESS:<span class="cov8" title="1">
                        op, err := jq.Parse(opWithSelector.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">data, err := op.Apply(msgInfo.MessageFullBody)
                        if err != nil </span><span class="cov8" title="1">{
                                if withinContractReference </span><span class="cov8" title="1">{
                                        opWithSelector.Operation.IdentifierTemplate = "*"
                                        break selectorSwitch</span>
                                }
                                // if the operation is not applicable to the message, skip it
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">bech32Addr := strings.Trim(string(data), "\"") // we need to trim the quotes around the string
                        // we expect a bech32 prefixed address, so lets convert to account address
                        accAddr, err := sdk.AccAddressFromBech32(bech32Addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">lengthPrefixed := address.MustLengthPrefix(accAddr)
                        opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString(lengthPrefixed),
                        )</span>
                case acltypes.AccessOperationSelectorType_SENDER_BECH32_ADDRESS:<span class="cov8" title="1">
                        senderAccAddress, err := sdk.AccAddressFromBech32(senderBech)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString(senderAccAddress),
                        )</span>
                case acltypes.AccessOperationSelectorType_SENDER_LENGTH_PREFIXED_ADDRESS:<span class="cov8" title="1">
                        senderAccAddress, err := sdk.AccAddressFromBech32(senderBech)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">lengthPrefixed := address.MustLengthPrefix(senderAccAddress)
                        opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString(lengthPrefixed),
                        )</span>
                case acltypes.AccessOperationSelectorType_CONTRACT_ADDRESS:<span class="cov0" title="0">
                        contractAddress, err := sdk.AccAddressFromBech32(opWithSelector.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hex.EncodeToString(contractAddress),
                        )</span>
                case acltypes.AccessOperationSelectorType_JQ_MESSAGE_CONDITIONAL:<span class="cov8" title="1">
                        op, err := jq.Parse(opWithSelector.Selector)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">_, err = op.Apply(msgInfo.MessageFullBody)
                        // if we are in a contract reference, we have to assume that this is necessary
                        if err != nil &amp;&amp; !withinContractReference </span><span class="cov8" title="1">{
                                // if the operation is not applicable to the message, skip it
                                continue</span>
                        }
                case acltypes.AccessOperationSelectorType_CONSTANT_STRING_TO_HEX:<span class="cov8" title="1">
                        hexStr := hex.EncodeToString([]byte(opWithSelector.Selector))
                        opWithSelector.Operation.IdentifierTemplate = fmt.Sprintf(
                                opWithSelector.Operation.IdentifierTemplate,
                                hexStr,
                        )</span>
                case acltypes.AccessOperationSelectorType_CONTRACT_REFERENCE:<span class="cov0" title="0">
                        // Deprecated for ImportContractReference function
                        continue</span>
                }
                <span class="cov8" title="1">selectedAccessOps.Add(*opWithSelector.Operation)</span>
        }

        <span class="cov8" title="1">return selectedAccessOps, nil</span>
}

func (k Keeper) SetWasmDependencyMapping(
        ctx sdk.Context,
        dependencyMapping acltypes.WasmDependencyMapping,
) error <span class="cov8" title="1">{
        err := types.ValidateWasmDependencyMapping(dependencyMapping)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        b := k.cdc.MustMarshal(&amp;dependencyMapping)

        contractAddr, err := sdk.AccAddressFromBech32(dependencyMapping.ContractAddress)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">resourceKey := types.GetWasmContractAddressKey(contractAddr)
        store.Set(resourceKey, b)
        return nil</span>
}

func (k Keeper) ResetWasmDependencyMapping(
        ctx sdk.Context,
        contractAddress sdk.AccAddress,
        reason string,
) error <span class="cov8" title="1">{
        dependencyMapping, err := k.GetRawWasmDependencyMapping(ctx, contractAddress)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        // keep `Enabled` true so that it won't cause all WASM resources to be synchronous
        dependencyMapping.BaseAccessOps = types.SynchronousWasmAccessOps()
        dependencyMapping.QueryAccessOps = []*acltypes.WasmAccessOperations{}
        dependencyMapping.ExecuteAccessOps = []*acltypes.WasmAccessOperations{}
        dependencyMapping.ResetReason = reason
        b := k.cdc.MustMarshal(dependencyMapping)
        resourceKey := types.GetWasmContractAddressKey(contractAddress)
        store.Set(resourceKey, b)
        return nil</span>
}

func (k Keeper) IterateWasmDependencies(ctx sdk.Context, handler func(wasmDependencyMapping acltypes.WasmDependencyMapping) (stop bool)) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)

        println("wasmKey", types.GetWasmMappingKey())
        iter := sdk.KVStorePrefixIterator(store, types.GetWasmMappingKey())
        defer iter.Close()
        for ; iter.Valid(); iter.Next() </span><span class="cov8" title="1">{
                dependencyMapping := acltypes.WasmDependencyMapping{}
                println("key", iter.Key())
                k.cdc.MustUnmarshal(iter.Value(), &amp;dependencyMapping)
                println(dependencyMapping.ContractAddress)
                if handler(dependencyMapping) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

// use -1 to indicate that it is prior to msgs in the tx
const ANTE_MSG_INDEX = int(-1)

func (k Keeper) BuildDependencyDag(ctx sdk.Context, txDecoder sdk.TxDecoder, anteDepGen sdk.AnteDepGenerator, txs [][]byte) (*types.Dag, error) <span class="cov8" title="1">{
        defer MeasureBuildDagDuration(time.Now(), "BuildDependencyDag")
        // contains the latest msg index for a specific Access Operation
        dependencyDag := types.NewDag()
        for txIndex, txBytes := range txs </span><span class="cov8" title="1">{
                tx, err := txDecoder(txBytes) // TODO: results in repetitive decoding for txs with runtx decode (potential optimization)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                // get the ante dependencies and add them to the dag
                <span class="cov8" title="1">anteDeps, err := anteDepGen([]acltypes.AccessOperation{}, tx)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">anteDepSet := make(map[acltypes.AccessOperation]struct{})

                for _, accessOp := range anteDeps </span><span class="cov8" title="1">{
                        // if found in set, we've already included this access Op in out ante dependencies, so skip it
                        if _, found := anteDepSet[accessOp]; found </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">anteDepSet[accessOp] = struct{}{}
                        err = types.ValidateAccessOp(accessOp)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">dependencyDag.AddNodeBuildDependency(ANTE_MSG_INDEX, txIndex, accessOp)</span>
                }

                <span class="cov8" title="1">msgs := tx.GetMsgs()
                for messageIndex, msg := range msgs </span><span class="cov8" title="1">{
                        if types.IsGovMessage(msg) </span><span class="cov8" title="1">{
                                return nil, types.ErrGovMsgInBlock
                        }</span>
                        <span class="cov8" title="1">msgDependencies := k.GetMessageDependencies(ctx, msg)
                        dependencyDag.AddAccessOpsForMsg(messageIndex, txIndex, msgDependencies)
                        for _, accessOp := range msgDependencies </span><span class="cov8" title="1">{
                                // make a new node in the dependency dag
                                dependencyDag.AddNodeBuildDependency(messageIndex, txIndex, accessOp)
                        }</span>
                }
        }
        // This should never happen base on existing DAG algorithm but it's not a significant
        // performance overhead (@BenchmarkAccessOpsBuildDependencyDag),
        // it would be better to keep this check. If a cyclic dependency
        // is ever found it may cause the chain to halt
        <span class="cov8" title="1">if !graph.Acyclic(&amp;dependencyDag) </span><span class="cov0" title="0">{
                return nil, types.ErrCycleInDAG
        }</span>
        <span class="cov8" title="1">return &amp;dependencyDag, nil</span>
}

// Measures the time taken to build dependency dag
// Metric Names:
//
//        sei_dag_build_duration_miliseconds
//        sei_dag_build_duration_miliseconds_count
//        sei_dag_build_duration_miliseconds_sum
func MeasureBuildDagDuration(start time.Time, method string) <span class="cov8" title="1">{
        metrics.MeasureSinceWithLabels(
                []string{"sei", "dag", "build", "milliseconds"},
                start.UTC(),
                []metrics.Label{telemetry.NewLabel("method", method)},
        )
}</span>

func (k Keeper) GetMessageDependencies(ctx sdk.Context, msg sdk.Msg) []acltypes.AccessOperation <span class="cov8" title="1">{
        // Default behavior is to get the static dependency mapping for the message
        messageKey := types.GenerateMessageKey(msg)
        dependencyMapping := k.GetResourceDependencyMapping(ctx, messageKey)
        if dependencyGenerator, ok := k.MessageDependencyGeneratorMapper[types.GenerateMessageKey(msg)]; dependencyMapping.DynamicEnabled &amp;&amp; ok </span><span class="cov8" title="1">{
                // if we have a dependency generator AND dynamic is enabled, use it
                if dependencies, err := dependencyGenerator(k, ctx, msg); err == nil </span><span class="cov8" title="1">{
                        // validate the access ops before using them
                        validateErr := types.ValidateAccessOps(dependencies)
                        if validateErr == nil </span><span class="cov8" title="1">{
                                return dependencies
                        }</span>
                        <span class="cov8" title="1">errorMessage := fmt.Sprintf("Invalid Access Ops for message=%s. %s", messageKey, validateErr.Error())
                        ctx.Logger().Error(errorMessage)</span>
                }
        }
        <span class="cov8" title="1">if dependencyMapping.DynamicEnabled </span><span class="cov8" title="1">{
                // there was an issue with dynamic generation, so lets disable it
                // this will not error, the validation check was done in previous calls already
                _ = k.SetDependencyMappingDynamicFlag(ctx, messageKey, false)
        }</span>
        <span class="cov8" title="1">return dependencyMapping.AccessOps</span>
}

func DefaultMessageDependencyGenerator() DependencyGeneratorMap <span class="cov8" title="1">{
        //TODO: define default granular behavior here
        return DependencyGeneratorMap{}
}</span>

func (m *DependencyGeneratorMap) Contains(key string) bool <span class="cov8" title="1">{
        _, ok := (*m)[types.MessageKey(key)]
        return ok
}</span>

func (k Keeper) GetStoreKey() sdk.StoreKey <span class="cov8" title="1">{
        return k.storeKey
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"
)

type msgServer struct {
        Keeper
}

// NewMsgServerImpl returns an implementation of the acl MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper) types.MsgServer <span class="cov8" title="1">{
        return &amp;msgServer{Keeper: keeper}
}</span>

var _ types.MsgServer = msgServer{}

func (k msgServer) RegisterWasmDependency(goCtx context.Context, msg *types.MsgRegisterWasmDependency) (*types.MsgRegisterWasmDependencyResponse, error) <span class="cov8" title="1">{
        ctx := sdk.UnwrapSDKContext(goCtx)

        err := k.SetWasmDependencyMapping(ctx, msg.WasmDependencyMapping)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ctx.EventManager().EmitEvent(
                sdk.NewEvent(
                        sdk.EventTypeMessage,
                        sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),
                ),
        )

        return &amp;types.MsgRegisterWasmDependencyResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package keeper

type optsFn func(*Keeper)

func (f optsFn) Apply(keeper *Keeper) <span class="cov8" title="1">{
        f(keeper)
}</span>

func WithDependencyMappingGenerator(generator DependencyGeneratorMap) optsFn <span class="cov8" title="1">{
        return optsFn(func(k *Keeper) </span><span class="cov8" title="1">{
                k.MessageDependencyGeneratorMapper = generator
        }</span>)
}

func WithDependencyGeneratorMappings(generator DependencyGeneratorMap) optsFn <span class="cov8" title="1">{
        return optsFn(func(k *Keeper) </span><span class="cov8" title="1">{
                k.MessageDependencyGeneratorMapper = k.MessageDependencyGeneratorMapper.Merge(generator)
        }</span>)
}

func (oldGenerator DependencyGeneratorMap) Merge(newGenerator DependencyGeneratorMap) DependencyGeneratorMap <span class="cov8" title="1">{
        for messageKey, dependencyGenerator := range newGenerator </span><span class="cov8" title="1">{
                // overwrite default generator mappings with the new ones
                oldGenerator[messageKey] = dependencyGenerator
        }</span>
        <span class="cov8" title="1">return oldGenerator</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package keeper

import (
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"

        sdk "github.com/cosmos/cosmos-sdk/types"
)

// GetParams returns the total set params.
func (k Keeper) GetParams(ctx sdk.Context) (params types.Params) <span class="cov8" title="1">{
        k.paramSpace.GetParamSet(ctx, &amp;params)
        return params
}</span>

// SetParams sets the total set of params.
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) <span class="cov8" title="1">{
        k.paramSpace.SetParamSet(ctx, &amp;params)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package migrations

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/cosmos/cosmos-sdk/x/accesscontrol/types"
)

func V1ToV2(ctx sdk.Context, storeKey sdk.StoreKey) error <span class="cov8" title="1">{
        store := ctx.KVStore(storeKey)
        iterator := sdk.KVStorePrefixIterator(store, types.GetWasmMappingKey())

        defer iterator.Close()
        keysToSet := [][]byte{}
        valsToSet := [][]byte{}
        for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                legacyMapping := acltypes.LegacyWasmDependencyMapping{}
                if err := legacyMapping.Unmarshal(iterator.Value()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">newMapping := acltypes.WasmDependencyMapping{}
                for _, legacyOp := range legacyMapping.AccessOps </span><span class="cov8" title="1">{
                        newMapping.BaseAccessOps = append(newMapping.BaseAccessOps, &amp;acltypes.WasmAccessOperation{
                                Operation:    legacyOp.Operation,
                                SelectorType: legacyOp.SelectorType,
                                Selector:     legacyOp.Selector,
                        })
                }</span>
                <span class="cov8" title="1">newMapping.ResetReason = legacyMapping.ResetReason
                newMapping.ContractAddress = legacyMapping.ContractAddress
                val, err := newMapping.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">keysToSet = append(keysToSet, iterator.Key())
                valsToSet = append(valsToSet, val)</span>
        }
        <span class="cov8" title="1">for i, key := range keysToSet </span><span class="cov8" title="1">{
                store.Set(key, valsToSet[i])
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package types

import (
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
)

type AccessOperationSet struct {
        ops map[acltypes.AccessOperation]struct{}
}

func NewEmptyAccessOperationSet() *AccessOperationSet <span class="cov0" title="0">{
        return &amp;AccessOperationSet{ops: map[acltypes.AccessOperation]struct{}{}}
}</span>

func NewAccessOperationSet(ops []acltypes.AccessOperation) *AccessOperationSet <span class="cov0" title="0">{
        set := NewEmptyAccessOperationSet()
        set.AddMultiple(ops)
        return set
}</span>

func (waos *AccessOperationSet) Add(op acltypes.AccessOperation) <span class="cov0" title="0">{
        waos.ops[op] = struct{}{}
}</span>

func (waos *AccessOperationSet) AddMultiple(ops []acltypes.AccessOperation) <span class="cov0" title="0">{
        for _, op := range ops </span><span class="cov0" title="0">{
                waos.Add(op)
        }</span>
}

func (waos *AccessOperationSet) Merge(other *AccessOperationSet) <span class="cov0" title="0">{
        for op := range other.ops </span><span class="cov0" title="0">{
                waos.Add(op)
        }</span>
}

func (waos *AccessOperationSet) Has(op acltypes.AccessOperation) bool <span class="cov0" title="0">{
        _, ok := waos.ops[op]
        return ok
}</span>

func (waos *AccessOperationSet) Size() int <span class="cov0" title="0">{
        return len(waos.ops)
}</span>

func (waos *AccessOperationSet) ToSlice() []acltypes.AccessOperation <span class="cov0" title="0">{
        res := []acltypes.AccessOperation{}
        hasCommitOp := false
        for op := range waos.ops </span><span class="cov0" title="0">{
                if op != *CommitAccessOp() </span><span class="cov0" title="0">{
                        res = append(res, op)
                }</span> else<span class="cov0" title="0"> {
                        hasCommitOp = true
                }</span>
        }
        <span class="cov0" title="0">if hasCommitOp </span><span class="cov0" title="0">{
                res = append(res, *CommitAccessOp())
        }</span>
        <span class="cov0" title="0">return res</span>
}

// TEST ONLY
func (waos *AccessOperationSet) HasIdentifier(identifier string) bool <span class="cov0" title="0">{
        for op := range waos.ops </span><span class="cov0" title="0">{
                if op.IdentifierTemplate == identifier </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (waos *AccessOperationSet) HasResourceType(rt acltypes.ResourceType) bool <span class="cov0" title="0">{
        for op := range waos.ops </span><span class="cov0" title="0">{
                if op.ResourceType == rt </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

func RegisterCodec(cdc *codec.LegacyAmino) <span class="cov8" title="1">{
        cdc.RegisterConcrete(
                &amp;MsgUpdateResourceDependencyMappingProposal{},
                "cosmos-sdk/MsgUpdateResourceDependencyMappingProposal",
                nil,
        )
        cdc.RegisterConcrete(
                &amp;MsgUpdateWasmDependencyMappingProposal{},
                "cosmos-sdk/MsgUpdateWasmDependencyMappingProposal",
                nil,
        )
}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov8" title="1">{
        registry.RegisterImplementations((*govtypes.Content)(nil),
                &amp;MsgUpdateResourceDependencyMappingProposal{},
        )
        registry.RegisterImplementations((*sdk.Msg)(nil),
                &amp;MsgRegisterWasmDependency{},
        )
}</span>

var ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
</pre>
		
		<pre class="file" id="file9" style="display: none">package types

import (
        "encoding/json"

        "github.com/cosmos/cosmos-sdk/codec"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
)

// NewGenesisState creates a new GenesisState object
func NewGenesisState(params Params, messageDependencyMapping []acltypes.MessageDependencyMapping, wasmDependencyMappings []acltypes.WasmDependencyMapping) *GenesisState <span class="cov0" title="0">{
        return &amp;GenesisState{
                Params:                   params,
                MessageDependencyMapping: messageDependencyMapping,
                WasmDependencyMappings:   wasmDependencyMappings,
        }
}</span>

// DefaultGenesisState - default GenesisState used by columbus-2
func DefaultGenesisState() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                Params:                   DefaultParams(),
                MessageDependencyMapping: DefaultMessageDependencyMapping(),
                WasmDependencyMappings:   DefaultWasmDependencyMappings(),
        }
}</span>

// ValidateGenesis validates the oracle genesis state
func ValidateGenesis(data GenesisState) error <span class="cov8" title="1">{
        for _, mapping := range data.MessageDependencyMapping </span><span class="cov0" title="0">{
                err := ValidateMessageDependencyMapping(mapping)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">for _, mapping := range data.WasmDependencyMappings </span><span class="cov0" title="0">{
                err := ValidateWasmDependencyMapping(mapping)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return data.Params.Validate()</span>
}

// GetGenesisStateFromAppState returns x/oracle GenesisState given raw application
// genesis state.
func GetGenesisStateFromAppState(cdc codec.JSONCodec, appState map[string]json.RawMessage) *GenesisState <span class="cov0" title="0">{
        var genesisState GenesisState

        if appState[ModuleName] != nil </span><span class="cov0" title="0">{
                cdc.MustUnmarshalJSON(appState[ModuleName], &amp;genesisState)
        }</span>

        <span class="cov0" title="0">return &amp;genesisState</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accesscontrol_x/genesis.proto

package types

import (
        fmt "fmt"
        accesscontrol "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GenesisState struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
        // mapping between every message type and its predetermined resource read/write sequence
        MessageDependencyMapping []accesscontrol.MessageDependencyMapping `protobuf:"bytes,2,rep,name=message_dependency_mapping,json=messageDependencyMapping,proto3" json:"message_dependency_mapping" yaml:"message_dependency_mapping"`
        WasmDependencyMappings   []accesscontrol.WasmDependencyMapping    `protobuf:"bytes,3,rep,name=wasm_dependency_mappings,json=wasmDependencyMappings,proto3" json:"wasm_dependency_mappings" yaml:"wasm_dependency_mappings"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_35812e6814a64fba, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func (m *GenesisState) GetMessageDependencyMapping() []accesscontrol.MessageDependencyMapping <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.MessageDependencyMapping
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *GenesisState) GetWasmDependencyMappings() []accesscontrol.WasmDependencyMapping <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.WasmDependencyMappings
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Params struct {
}

func (m *Params) Reset()      <span class="cov0" title="0">{ *m = Params{} }</span>
func (*Params) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_35812e6814a64fba, []int{1}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "cosmos.accesscontrol_x.v1beta1.GenesisState")
        proto.RegisterType((*Params)(nil), "cosmos.accesscontrol_x.v1beta1.Params")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("cosmos/accesscontrol_x/genesis.proto", fileDescriptor_35812e6814a64fba)
}</span>

var fileDescriptor_35812e6814a64fba = []byte{
        // 340 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0x41, 0x4b, 0x02, 0x41,
        0x1c, 0xc5, 0x77, 0x52, 0x3c, 0xac, 0xd1, 0x61, 0x89, 0x58, 0x3c, 0xcc, 0xda, 0x12, 0x65, 0x87,
        0x66, 0x51, 0xa1, 0x83, 0x47, 0x11, 0xba, 0x24, 0x84, 0x1d, 0x82, 0x2e, 0x32, 0x8e, 0xc3, 0x24,
        0x39, 0x3b, 0x83, 0xff, 0x29, 0xf5, 0x53, 0xd4, 0x29, 0xba, 0xd5, 0xc7, 0xf1, 0xe8, 0xb1, 0x93,
        0x84, 0x7e, 0x83, 0x3e, 0x41, 0xb8, 0x23, 0x42, 0xb6, 0x7a, 0x9a, 0x19, 0x78, 0xbf, 0xf7, 0x1e,
        0xf3, 0xdc, 0x13, 0xa6, 0x40, 0x2a, 0x88, 0x28, 0x63, 0x1c, 0x80, 0xa9, 0xd8, 0x0c, 0x54, 0xbf,
        0x3d, 0x8a, 0x04, 0x8f, 0x39, 0xf4, 0x80, 0xe8, 0x81, 0x32, 0xca, 0xc3, 0x56, 0x45, 0x36, 0x54,
        0xe4, 0xb9, 0xdc, 0xe1, 0x86, 0x96, 0x0b, 0x87, 0x42, 0x09, 0x95, 0x48, 0xa3, 0xe5, 0xcd, 0x52,
        0x85, 0x52, 0x9a, 0xf7, 0xdf, 0x97, 0x55, 0x86, 0x2f, 0x19, 0x77, 0xff, 0xca, 0x26, 0xde, 0x1a,
        0x6a, 0xb8, 0xd7, 0x70, 0x73, 0x9a, 0x0e, 0xa8, 0x04, 0x1f, 0x15, 0x51, 0x29, 0x5f, 0x39, 0x25,
        0xbb, 0x1b, 0x90, 0x9b, 0x44, 0x5d, 0xcf, 0x4e, 0x66, 0x81, 0xd3, 0x5a, 0xb1, 0xde, 0x07, 0x72,
        0x0b, 0x92, 0x03, 0x50, 0xc1, 0xdb, 0x5d, 0xae, 0x79, 0xdc, 0xe5, 0x31, 0x1b, 0xb7, 0x25, 0xd5,
        0xba, 0x17, 0x0b, 0x7f, 0xaf, 0x98, 0x29, 0xe5, 0x2b, 0x97, 0xa9, 0xd6, 0x6b, 0xe3, 0xa6, 0xe5,
        0x1b, 0x6b, 0xbc, 0x69, 0xe9, 0xfa, 0xf9, 0x32, 0xea, 0x67, 0x16, 0x1c, 0x8f, 0xa9, 0xec, 0xd7,
        0xc2, 0xed, 0x39, 0x61, 0xcb, 0x97, 0x5b, 0x4c, 0xbc, 0x37, 0xe4, 0xfa, 0x43, 0x0a, 0x32, 0x05,
        0x03, 0x3f, 0x93, 0xf4, 0xab, 0xee, 0xee, 0x77, 0x47, 0x41, 0xfe, 0x2f, 0x77, 0xb6, 0x2a, 0x17,
        0xd8, 0x72, 0xdb, 0x22, 0xc2, 0xd6, 0xd1, 0x30, 0x8d, 0x87, 0xf0, 0xc0, 0xcd, 0xd9, 0x2f, 0xad,
        0x65, 0xdf, 0x3f, 0x03, 0xa7, 0x7e, 0x3d, 0x99, 0x63, 0x34, 0x9d, 0x63, 0xf4, 0x3d, 0xc7, 0xe8,
        0x75, 0x81, 0x9d, 0xe9, 0x02, 0x3b, 0x5f, 0x0b, 0xec, 0xdc, 0x57, 0x44, 0xcf, 0x3c, 0x3c, 0x75,
        0x08, 0x53, 0x32, 0x5a, 0x0d, 0x6e, 0x8f, 0x0b, 0xe8, 0x3e, 0x46, 0xa3, 0x8d, 0xf5, 0xcd, 0x58,
        0x73, 0xe8, 0xe4, 0x92, 0xd9, 0xab, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x42, 0x1c, 0x49, 0x84,
        0x7e, 0x02, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WasmDependencyMappings) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.WasmDependencyMappings) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.WasmDependencyMappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MessageDependencyMapping) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MessageDependencyMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MessageDependencyMapping </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if len(m.WasmDependencyMappings) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.WasmDependencyMappings </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MessageDependencyMapping = append(m.MessageDependencyMapping, accesscontrol.MessageDependencyMapping{})
                        if err := m.MessageDependencyMapping[len(m.MessageDependencyMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMappings", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WasmDependencyMappings = append(m.WasmDependencyMappings, accesscontrol.WasmDependencyMapping{})
                        if err := m.WasmDependencyMappings[len(m.WasmDependencyMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        "fmt"
        "strings"

        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

const (
        ProposalUpdateResourceDependencyMapping = "UpdateResourceDependencyMapping"
        ProposalUpdateWasmDependencyMapping     = "UpdateWasmDependencyMapping"
)

func init() <span class="cov8" title="1">{
        // for routing
        govtypes.RegisterProposalType(ProposalUpdateResourceDependencyMapping)
        govtypes.RegisterProposalType(ProposalUpdateWasmDependencyMapping)
        // for marshal and unmarshal
        govtypes.RegisterProposalTypeCodec(&amp;MsgUpdateResourceDependencyMappingProposal{}, "accesscontrol/MsgUpdateResourceDependencyMappingProposal")
        govtypes.RegisterProposalTypeCodec(&amp;MsgUpdateWasmDependencyMappingProposal{}, "accesscontrol/MsgUpdateWasmDependencyMappingProposal")
}</span>

var _ govtypes.Content = &amp;MsgUpdateResourceDependencyMappingProposal{}
var _ govtypes.Content = &amp;MsgUpdateWasmDependencyMappingProposal{}

func NewMsgUpdateResourceDependencyMappingProposal(title, description string, messageDependencyMapping []acltypes.MessageDependencyMapping) *MsgUpdateResourceDependencyMappingProposal <span class="cov0" title="0">{
        return &amp;MsgUpdateResourceDependencyMappingProposal{title, description, messageDependencyMapping}
}</span>

func (p *MsgUpdateResourceDependencyMappingProposal) GetTitle() string <span class="cov0" title="0">{ return p.Title }</span>

func (p *MsgUpdateResourceDependencyMappingProposal) GetDescription() string <span class="cov0" title="0">{ return p.Description }</span>

func (p *MsgUpdateResourceDependencyMappingProposal) ProposalRoute() string <span class="cov0" title="0">{ return RouterKey }</span>

func (p *MsgUpdateResourceDependencyMappingProposal) ProposalType() string <span class="cov0" title="0">{
        return ProposalUpdateResourceDependencyMapping
}</span>

func (p *MsgUpdateResourceDependencyMappingProposal) ValidateBasic() error <span class="cov0" title="0">{
        err := govtypes.ValidateAbstract(p)
        return err
}</span>

func (p MsgUpdateResourceDependencyMappingProposal) String() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(
                fmt.Sprintf(`Add Creators to Denom Fee Whitelist Proposal:
                        Title:       %s
                        Description: %s
                        Changes:
                        `,
                        p.Title, p.Description))

        for _, depMapping := range p.MessageDependencyMapping </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf(`                Change:
                        MessageDependencyMapping: %s
                `, depMapping.String()))
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

func NewMsgUpdateWasmDependencyMappingProposal(title, description, contractAddr string, wasmDependencyMapping acltypes.WasmDependencyMapping) *MsgUpdateWasmDependencyMappingProposal <span class="cov0" title="0">{
        return &amp;MsgUpdateWasmDependencyMappingProposal{title, description, contractAddr, wasmDependencyMapping}
}</span>

func (p *MsgUpdateWasmDependencyMappingProposal) GetTitle() string <span class="cov0" title="0">{ return p.Title }</span>

func (p *MsgUpdateWasmDependencyMappingProposal) GetDescription() string <span class="cov0" title="0">{ return p.Description }</span>

func (p *MsgUpdateWasmDependencyMappingProposal) ProposalRoute() string <span class="cov0" title="0">{ return RouterKey }</span>

func (p *MsgUpdateWasmDependencyMappingProposal) ProposalType() string <span class="cov0" title="0">{
        return ProposalUpdateWasmDependencyMapping
}</span>

func (p *MsgUpdateWasmDependencyMappingProposal) ValidateBasic() error <span class="cov0" title="0">{
        err := govtypes.ValidateAbstract(p)
        return err
}</span>

func (p MsgUpdateWasmDependencyMappingProposal) String() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(
                fmt.Sprintf(`Add Creators to Denom Fee Whitelist Proposal:
                        Title:       %s
                        Description: %s
                        ContractAddress: %s
                        Change:
                        `,
                        p.Title, p.Description, p.ContractAddress))

        b.WriteString(fmt.Sprintf(`
                WasmDependencyMapping: %s
        `, p.WasmDependencyMapping.String()))
        return b.String()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accesscontrol_x/gov.proto

package types

import (
        fmt "fmt"
        accesscontrol "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgUpdateResourceDependencyMappingProposal struct {
        Title                    string                                   `protobuf:"bytes,1,opt,name=title,proto3" json:"title" yaml:"title"`
        Description              string                                   `protobuf:"bytes,2,opt,name=description,proto3" json:"description" yaml:"description"`
        MessageDependencyMapping []accesscontrol.MessageDependencyMapping `protobuf:"bytes,3,rep,name=message_dependency_mapping,json=messageDependencyMapping,proto3" json:"message_dependency_mapping" yaml:"message_dependency_mapping"`
}

func (m *MsgUpdateResourceDependencyMappingProposal) Reset() <span class="cov0" title="0">{
        *m = MsgUpdateResourceDependencyMappingProposal{}
}</span>
func (*MsgUpdateResourceDependencyMappingProposal) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*MsgUpdateResourceDependencyMappingProposal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3e058bfaa38d4c4c, []int{0}
}</span>
func (m *MsgUpdateResourceDependencyMappingProposal) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateResourceDependencyMappingProposal.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateResourceDependencyMappingProposal) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposal.Merge(m, src)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposal) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateResourceDependencyMappingProposal) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposal.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateResourceDependencyMappingProposal proto.InternalMessageInfo

type MsgUpdateResourceDependencyMappingProposalJsonFile struct {
        Title                    string                                   `protobuf:"bytes,1,opt,name=title,proto3" json:"title" yaml:"title"`
        Description              string                                   `protobuf:"bytes,2,opt,name=description,proto3" json:"description" yaml:"description"`
        Deposit                  string                                   `protobuf:"bytes,3,opt,name=deposit,proto3" json:"deposit" yaml:"deposit"`
        MessageDependencyMapping []accesscontrol.MessageDependencyMapping `protobuf:"bytes,4,rep,name=message_dependency_mapping,json=messageDependencyMapping,proto3" json:"message_dependency_mapping" yaml:"message_dependency_mapping"`
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) Reset() <span class="cov0" title="0">{
        *m = MsgUpdateResourceDependencyMappingProposalJsonFile{}
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*MsgUpdateResourceDependencyMappingProposalJsonFile) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*MsgUpdateResourceDependencyMappingProposalJsonFile) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3e058bfaa38d4c4c, []int{1}
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalJsonFile.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalJsonFile.Merge(m, src)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalJsonFile.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalJsonFile proto.InternalMessageInfo

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) GetTitle() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) GetDeposit() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Deposit
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) GetMessageDependencyMapping() []accesscontrol.MessageDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MessageDependencyMapping
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MsgUpdateResourceDependencyMappingProposalResponse struct {
}

func (m *MsgUpdateResourceDependencyMappingProposalResponse) Reset() <span class="cov0" title="0">{
        *m = MsgUpdateResourceDependencyMappingProposalResponse{}
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*MsgUpdateResourceDependencyMappingProposalResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*MsgUpdateResourceDependencyMappingProposalResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3e058bfaa38d4c4c, []int{2}
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateResourceDependencyMappingProposalResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalResponse.Merge(m, src)
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateResourceDependencyMappingProposalResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateResourceDependencyMappingProposalResponse proto.InternalMessageInfo

type MsgUpdateWasmDependencyMappingProposal struct {
        Title                 string                              `protobuf:"bytes,1,opt,name=title,proto3" json:"title" yaml:"title"`
        Description           string                              `protobuf:"bytes,2,opt,name=description,proto3" json:"description" yaml:"description"`
        ContractAddress       string                              `protobuf:"bytes,3,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address" yaml:"contract_address"`
        WasmDependencyMapping accesscontrol.WasmDependencyMapping `protobuf:"bytes,4,opt,name=wasm_dependency_mapping,json=wasmDependencyMapping,proto3" json:"wasm_dependency_mapping" yaml:"wasm_dependency_mapping"`
}

func (m *MsgUpdateWasmDependencyMappingProposal) Reset() <span class="cov0" title="0">{
        *m = MsgUpdateWasmDependencyMappingProposal{}
}</span>
func (*MsgUpdateWasmDependencyMappingProposal) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*MsgUpdateWasmDependencyMappingProposal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3e058bfaa38d4c4c, []int{3}
}</span>
func (m *MsgUpdateWasmDependencyMappingProposal) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateWasmDependencyMappingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateWasmDependencyMappingProposal.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateWasmDependencyMappingProposal) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateWasmDependencyMappingProposal.Merge(m, src)
}</span>
func (m *MsgUpdateWasmDependencyMappingProposal) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateWasmDependencyMappingProposal) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateWasmDependencyMappingProposal.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateWasmDependencyMappingProposal proto.InternalMessageInfo

type MsgUpdateWasmDependencyMappingProposalJsonFile struct {
        Title                 string                              `protobuf:"bytes,1,opt,name=title,proto3" json:"title" yaml:"title"`
        Description           string                              `protobuf:"bytes,2,opt,name=description,proto3" json:"description" yaml:"description"`
        Deposit               string                              `protobuf:"bytes,3,opt,name=deposit,proto3" json:"deposit" yaml:"deposit"`
        ContractAddress       string                              `protobuf:"bytes,4,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address" yaml:"contract_address"`
        WasmDependencyMapping accesscontrol.WasmDependencyMapping `protobuf:"bytes,5,opt,name=wasm_dependency_mapping,json=wasmDependencyMapping,proto3" json:"wasm_dependency_mapping" yaml:"wasm_dependency_mapping"`
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) Reset() <span class="cov0" title="0">{
        *m = MsgUpdateWasmDependencyMappingProposalJsonFile{}
}</span>
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*MsgUpdateWasmDependencyMappingProposalJsonFile) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*MsgUpdateWasmDependencyMappingProposalJsonFile) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_3e058bfaa38d4c4c, []int{4}
}</span>
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateWasmDependencyMappingProposalJsonFile.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateWasmDependencyMappingProposalJsonFile.Merge(m, src)
}</span>
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateWasmDependencyMappingProposalJsonFile.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateWasmDependencyMappingProposalJsonFile proto.InternalMessageInfo

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) GetTitle() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) GetDeposit() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Deposit
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) GetContractAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContractAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) GetWasmDependencyMapping() accesscontrol.WasmDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WasmDependencyMapping
        }</span>
        <span class="cov0" title="0">return accesscontrol.WasmDependencyMapping{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgUpdateResourceDependencyMappingProposal)(nil), "cosmos.accesscontrol.v1beta1.MsgUpdateResourceDependencyMappingProposal")
        proto.RegisterType((*MsgUpdateResourceDependencyMappingProposalJsonFile)(nil), "cosmos.accesscontrol.v1beta1.MsgUpdateResourceDependencyMappingProposalJsonFile")
        proto.RegisterType((*MsgUpdateResourceDependencyMappingProposalResponse)(nil), "cosmos.accesscontrol.v1beta1.MsgUpdateResourceDependencyMappingProposalResponse")
        proto.RegisterType((*MsgUpdateWasmDependencyMappingProposal)(nil), "cosmos.accesscontrol.v1beta1.MsgUpdateWasmDependencyMappingProposal")
        proto.RegisterType((*MsgUpdateWasmDependencyMappingProposalJsonFile)(nil), "cosmos.accesscontrol.v1beta1.MsgUpdateWasmDependencyMappingProposalJsonFile")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("cosmos/accesscontrol_x/gov.proto", fileDescriptor_3e058bfaa38d4c4c) }</span>

var fileDescriptor_3e058bfaa38d4c4c = []byte{
        // 547 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0xcf, 0x8b, 0xd3, 0x40,
        0x14, 0x4e, 0x36, 0xbb, 0x8a, 0x53, 0xd1, 0x25, 0x28, 0x5b, 0x8b, 0x66, 0xea, 0xa0, 0x4b, 0x15,
        0x4c, 0xd8, 0xae, 0x28, 0xec, 0xcd, 0x22, 0x0a, 0x62, 0x41, 0x02, 0x22, 0xec, 0xa5, 0x4c, 0x93,
        0x21, 0x06, 0x9b, 0xcc, 0x90, 0x37, 0xfb, 0xa3, 0x37, 0x8f, 0x7a, 0x13, 0xbc, 0x78, 0xb3, 0x27,
        0xff, 0x96, 0x3d, 0xee, 0x45, 0x10, 0x91, 0x41, 0xda, 0x8b, 0xf4, 0xd8, 0xbf, 0x40, 0xcc, 0xb4,
        0x4b, 0x77, 0x37, 0x5d, 0xd7, 0x8b, 0xd5, 0x53, 0x92, 0xef, 0x7d, 0xdf, 0x7b, 0x2f, 0xef, 0xe3,
        0xf1, 0x50, 0x35, 0xe0, 0x90, 0x70, 0xf0, 0x68, 0x10, 0x30, 0x80, 0x80, 0xa7, 0x32, 0xe3, 0x9d,
        0xd6, 0xae, 0x17, 0xf1, 0x6d, 0x57, 0x64, 0x5c, 0x72, 0xfb, 0xaa, 0x66, 0xb8, 0x87, 0x18, 0xee,
        0xf6, 0x5a, 0x9b, 0x49, 0xba, 0x56, 0xb9, 0x14, 0xf1, 0x88, 0xe7, 0x44, 0xef, 0xd7, 0x9b, 0xd6,
        0x54, 0x6e, 0x14, 0x65, 0xf5, 0x02, 0x9e, 0x82, 0xa4, 0xa9, 0x84, 0x31, 0xab, 0x56, 0xc8, 0x3a,
        0x5c, 0x27, 0x67, 0x92, 0xaf, 0x0b, 0xe8, 0x76, 0x13, 0xa2, 0xe7, 0x22, 0xa4, 0x92, 0xf9, 0x0c,
        0xf8, 0x56, 0x16, 0xb0, 0x87, 0x4c, 0xb0, 0x34, 0x64, 0x69, 0xd0, 0x6d, 0x52, 0x21, 0xe2, 0x34,
        0x7a, 0x96, 0x71, 0xc1, 0x81, 0x76, 0x6c, 0x0f, 0x2d, 0xc9, 0x58, 0x76, 0x58, 0xd9, 0xac, 0x9a,
        0xb5, 0x73, 0x8d, 0x2b, 0x43, 0x85, 0x35, 0x30, 0x52, 0xf8, 0x7c, 0x97, 0x26, 0x9d, 0x0d, 0x92,
        0x7f, 0x12, 0x5f, 0xc3, 0xf6, 0x63, 0x54, 0x0a, 0x19, 0x04, 0x59, 0x2c, 0x64, 0xcc, 0xd3, 0xf2,
        0x42, 0x2e, 0xbb, 0x39, 0x54, 0x78, 0x1a, 0x1e, 0x29, 0x6c, 0x6b, 0xf1, 0x14, 0x48, 0xfc, 0x69,
        0x8a, 0xfd, 0xd1, 0x44, 0x95, 0x84, 0x01, 0xd0, 0x88, 0xb5, 0xc2, 0x83, 0xfe, 0x5a, 0x89, 0x6e,
        0xb0, 0x6c, 0x55, 0xad, 0x5a, 0xa9, 0x7e, 0xcf, 0x3d, 0x69, 0xa4, 0x6e, 0x53, 0xeb, 0x8f, 0xfd,
        0x5e, 0xe3, 0xd6, 0x9e, 0xc2, 0xc6, 0x48, 0xe1, 0xeb, 0xba, 0x8b, 0xd9, 0x75, 0x88, 0x5f, 0x4e,
        0x66, 0x24, 0xd9, 0x58, 0x7e, 0xd3, 0xc3, 0xc6, 0x87, 0x1e, 0x36, 0x7e, 0xf4, 0xb0, 0xf1, 0xfa,
        0x5b, 0xd5, 0x20, 0x6f, 0x2d, 0x54, 0x3f, 0xfd, 0x70, 0x9f, 0x00, 0x4f, 0x1f, 0xc5, 0x1d, 0x36,
        0xc7, 0x21, 0xdf, 0x47, 0x67, 0x43, 0x26, 0x38, 0xc4, 0xb2, 0x6c, 0xe5, 0x49, 0xae, 0x0d, 0x15,
        0x9e, 0x40, 0x23, 0x85, 0x2f, 0x4c, 0x12, 0xe4, 0x00, 0xf1, 0x27, 0xa1, 0xdf, 0xb9, 0xb3, 0x38,
        0x77, 0x77, 0xc8, 0xdd, 0x3f, 0xb1, 0xc2, 0x67, 0x20, 0x78, 0x0a, 0x8c, 0x7c, 0xb2, 0xd0, 0xea,
        0x81, 0xec, 0x05, 0x85, 0xe4, 0x5f, 0x5c, 0x8d, 0x4d, 0xb4, 0x9c, 0xcf, 0x92, 0x06, 0xb2, 0x45,
        0xc3, 0x30, 0x63, 0x00, 0x63, 0xfb, 0xbc, 0xa1, 0xc2, 0xc7, 0x62, 0x23, 0x85, 0x57, 0x74, 0xca,
        0xa3, 0x11, 0xe2, 0x5f, 0x9c, 0x40, 0x0f, 0x34, 0x62, 0xbf, 0x37, 0xd1, 0xca, 0x0e, 0x85, 0xa4,
        0xd8, 0x55, 0xb3, 0x56, 0xaa, 0xaf, 0x9f, 0xec, 0x6a, 0xe1, 0xd0, 0x1a, 0xab, 0x63, 0x4b, 0x1d,
        0xdd, 0xc8, 0x8c, 0x0a, 0xc4, 0xbf, 0xbc, 0x53, 0x24, 0x2f, 0x58, 0xb5, 0xcf, 0x16, 0x72, 0x4f,
        0x67, 0xd4, 0xff, 0xbc, 0x66, 0x45, 0x4e, 0x2f, 0xfe, 0x05, 0xa7, 0x97, 0xe6, 0xe5, 0x74, 0xe3,
        0xe9, 0x5e, 0xdf, 0x31, 0xf7, 0xfb, 0x8e, 0xf9, 0xbd, 0xef, 0x98, 0xef, 0x06, 0x8e, 0xb1, 0x3f,
        0x70, 0x8c, 0x2f, 0x03, 0xc7, 0xd8, 0xac, 0x47, 0xb1, 0x7c, 0xb9, 0xd5, 0x76, 0x03, 0x9e, 0x78,
        0xe3, 0x73, 0xa7, 0x1f, 0x77, 0x20, 0x7c, 0xe5, 0xed, 0x1e, 0xb9, 0x7d, 0xb2, 0x2b, 0x18, 0xb4,
        0xcf, 0xe4, 0x47, 0x6f, 0xfd, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x4c, 0x68, 0xe0, 0x9c,
        0x07, 0x00, 0x00,
}

func (m *MsgUpdateResourceDependencyMappingProposal) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateResourceDependencyMappingProposal) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateResourceDependencyMappingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MessageDependencyMapping) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MessageDependencyMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGov(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MessageDependencyMapping) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MessageDependencyMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGov(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x22</span>
                }
        }
        <span class="cov0" title="0">if len(m.Deposit) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Deposit)
                copy(dAtA[i:], m.Deposit)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Deposit)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateResourceDependencyMappingProposalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateWasmDependencyMappingProposal) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateWasmDependencyMappingProposal) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateWasmDependencyMappingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.WasmDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGov(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.ContractAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ContractAddress)
                copy(dAtA[i:], m.ContractAddress)
                i = encodeVarintGov(dAtA, i, uint64(len(m.ContractAddress)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.WasmDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGov(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x2a
        if len(m.ContractAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ContractAddress)
                copy(dAtA[i:], m.ContractAddress)
                i = encodeVarintGov(dAtA, i, uint64(len(m.ContractAddress)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.Deposit) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Deposit)
                copy(dAtA[i:], m.Deposit)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Deposit)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintGov(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGov(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgUpdateResourceDependencyMappingProposal) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MessageDependencyMapping </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGov(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Deposit)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">if len(m.MessageDependencyMapping) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MessageDependencyMapping </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGov(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateResourceDependencyMappingProposalResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateWasmDependencyMappingProposal) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ContractAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.WasmDependencyMapping.Size()
        n += 1 + l + sovGov(uint64(l))
        return n</span>
}

func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Deposit)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.ContractAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.WasmDependencyMapping.Size()
        n += 1 + l + sovGov(uint64(l))
        return n</span>
}

func sovGov(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGov(x uint64) (n int) <span class="cov0" title="0">{
        return sovGov(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgUpdateResourceDependencyMappingProposal) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposal: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MessageDependencyMapping = append(m.MessageDependencyMapping, accesscontrol.MessageDependencyMapping{})
                        if err := m.MessageDependencyMapping[len(m.MessageDependencyMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateResourceDependencyMappingProposalJsonFile) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposalJsonFile: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposalJsonFile: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Deposit = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MessageDependencyMapping = append(m.MessageDependencyMapping, accesscontrol.MessageDependencyMapping{})
                        if err := m.MessageDependencyMapping[len(m.MessageDependencyMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateResourceDependencyMappingProposalResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposalResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateResourceDependencyMappingProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateWasmDependencyMappingProposal) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateWasmDependencyMappingProposal: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateWasmDependencyMappingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ContractAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.WasmDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateWasmDependencyMappingProposalJsonFile) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateWasmDependencyMappingProposalJsonFile: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateWasmDependencyMappingProposalJsonFile: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Deposit = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ContractAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.WasmDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGov(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGov
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGov
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGov        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGov          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGov = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

import (
        fmt "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
        mapset "github.com/deckarep/golang-set"
)

type DagNodeID int

// Alias for mapping resource identifier to dag node IDs
type ResourceIdentifierNodeIDMapping = map[string][]DagNodeID

type MsgIndexToAccessOpMapping = map[int][]acltypes.AccessOperation

type ResourceAccess struct {
        ResourceType acltypes.ResourceType
        AccessType   acltypes.AccessType
}

type DagNode struct {
        NodeID          DagNodeID
        MessageIndex    int
        TxIndex         int
        AccessOperation acltypes.AccessOperation
}

type DagEdge struct {
        FromNodeID DagNodeID
        ToNodeID   DagNodeID
}

type Dag struct {
        NodeMap                map[DagNodeID]DagNode
        EdgesMap               map[DagNodeID][]DagEdge                            // maps node Id (from node) and contains edge info
        ResourceAccessMap      map[ResourceAccess]ResourceIdentifierNodeIDMapping // maps resource type and access type to identifiers + node IDs
        TxIndexMap             map[int]DagNodeID                                  // tracks latest node ID for a tx index
        NextID                 DagNodeID
        CompletionSignalingMap map[int]MessageCompletionSignalMapping // keys on tx index
        BlockingSignalsMap     map[int]MessageCompletionSignalMapping // keys on tx index
        TxMsgAccessOpMapping   map[int]MsgIndexToAccessOpMapping                // Mapping of Tx Index -&gt; Msg Index -&gt; All access ops
}

// Alias for mapping MessageIndexId -&gt; AccessOperations -&gt; CompletionSignals
type MessageCompletionSignalMapping = map[int]map[acltypes.AccessOperation][]CompletionSignal

type CompletionSignal struct {
        FromNodeID                DagNodeID
        ToNodeID                  DagNodeID
        CompletionAccessOperation acltypes.AccessOperation // this is the access operation that must complete in order to send the signal
        BlockedAccessOperation    acltypes.AccessOperation // this is the access operation that is blocked by the completion access operation
        Channel                   chan interface{}
}

var (
        ErrCycleInDAG    = fmt.Errorf("cycle detected in DAG")
        ErrGovMsgInBlock = fmt.Errorf("gov msg in block")
)

func (dag *Dag) GetCompletionSignal(edge DagEdge) *CompletionSignal <span class="cov8" title="1">{
        // only if tx indexes are different
        fromNode := dag.NodeMap[edge.FromNodeID]
        toNode := dag.NodeMap[edge.ToNodeID]
        if fromNode.TxIndex == toNode.TxIndex </span><span class="cov0" title="0">{
                // TODO: we may be able to remove this now since we don't created edges within a tx now
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;CompletionSignal{
                FromNodeID:                fromNode.NodeID,
                ToNodeID:                  toNode.NodeID,
                CompletionAccessOperation: fromNode.AccessOperation,
                BlockedAccessOperation:    toNode.AccessOperation,
                // channel used for signalling
                // use buffered channel so that writing to channel won't be blocked by reads
                Channel: make(chan interface{}, 1),
        }</span>
}

// Order returns the number of vertices in a graph.
func (dag Dag) Order() int <span class="cov8" title="1">{
        return len(dag.NodeMap)
}</span>

// Visit calls the do function for each neighbor w of vertex v, used by the graph acyclic validator
func (dag Dag) Visit(v int, do func(w int, c int64) (skip bool)) (aborted bool) <span class="cov8" title="1">{
        for _, edge := range dag.EdgesMap[DagNodeID(v)] </span><span class="cov8" title="1">{
                // just have cost as zero because we only need for acyclic validation purposes
                if do(int(edge.ToNodeID), 0) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func NewDag() Dag <span class="cov8" title="1">{
        return Dag{
                NodeMap:                make(map[DagNodeID]DagNode),
                EdgesMap:               make(map[DagNodeID][]DagEdge),
                ResourceAccessMap:      make(map[ResourceAccess]ResourceIdentifierNodeIDMapping),
                TxIndexMap:             make(map[int]DagNodeID),
                NextID:                 0,
                CompletionSignalingMap: make(map[int]MessageCompletionSignalMapping),
                BlockingSignalsMap:     make(map[int]MessageCompletionSignalMapping),
                TxMsgAccessOpMapping:   make(map[int]MsgIndexToAccessOpMapping),
        }
}</span>

func GetResourceAccess(accessOp acltypes.AccessOperation) ResourceAccess <span class="cov8" title="1">{
        return ResourceAccess{
                accessOp.ResourceType,
                accessOp.AccessType,
        }
}</span>


func (dag *Dag) AddAccessOpsForMsg(messageIndex int, txIndex int, accessOps []acltypes.AccessOperation) <span class="cov0" title="0">{
        if _, ok := dag.TxMsgAccessOpMapping[txIndex]; !ok </span><span class="cov0" title="0">{
                dag.TxMsgAccessOpMapping[txIndex] = make(MsgIndexToAccessOpMapping)
        }</span>

        <span class="cov0" title="0">dag.TxMsgAccessOpMapping[txIndex][messageIndex] = accessOps</span>
}


func (dag *Dag) AddNode(messageIndex int, txIndex int, accessOp acltypes.AccessOperation) DagNode <span class="cov8" title="1">{
        dagNode := DagNode{
                NodeID:          dag.NextID,
                MessageIndex:    messageIndex,
                TxIndex:         txIndex,
                AccessOperation: accessOp,
        }
        dag.NodeMap[dag.NextID] = dagNode
        dag.NextID++
        return dagNode
}</span>

func (dag *Dag) AddEdge(fromIndex DagNodeID, toIndex DagNodeID) *DagEdge <span class="cov8" title="1">{
        // no-ops if the from or to node doesn't exist
        if _, ok := dag.NodeMap[fromIndex]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if _, ok := dag.NodeMap[toIndex]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Processing in a given TX is sequential so no need for dependency
        <span class="cov8" title="1">if dag.NodeMap[fromIndex].TxIndex == dag.NodeMap[toIndex].TxIndex </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">newEdge := DagEdge{fromIndex, toIndex}
        dag.EdgesMap[fromIndex] = append(dag.EdgesMap[fromIndex], newEdge)
        return &amp;newEdge</span>
}

// This function is a helper used to build the dependency graph one access operation at a time.
// It will first add a node corresponding to the tx index and access operation (linking it to the previous most recent node for that tx if applicable)
// and then will build edges from any access operations on which the new node is dependent.
//
// This will be accomplished using the AccessOpsMap in dag which keeps track of which nodes access which resources.
// It will then create an edge between the relevant node upon which it is dependent, and this edge can later be used to build the completion signals
// that will allow the dependent goroutines to cordinate execution safely.
//
// It will also register the new node with AccessOpsMap so that future nodes that amy be dependent on this one can properly identify the dependency.
func (dag *Dag) AddNodeBuildDependency(messageIndex int, txIndex int, accessOp acltypes.AccessOperation) <span class="cov8" title="1">{
        dagNode := dag.AddNode(messageIndex, txIndex, accessOp)
        // update tx index map
        dag.TxIndexMap[txIndex] = dagNode.NodeID

        nodeDependencies := dag.GetNodeDependencies(dagNode)
        // build edges for each of the dependencies
        for _, nodeDependency := range nodeDependencies </span><span class="cov8" title="1">{
                edge := dag.AddEdge(nodeDependency, dagNode.NodeID)
                // also add completion signal corresponding to the edge
                if edge != nil </span><span class="cov8" title="1">{
                        maybeCompletionSignal := dag.GetCompletionSignal(*edge)
                        if maybeCompletionSignal != nil </span><span class="cov8" title="1">{
                                completionSignal := *maybeCompletionSignal
                                dag.AddCompletionSignal(completionSignal)
                        }</span>
                }
        }

        // update access ops map with the latest node id using a specific access op
        <span class="cov8" title="1">resourceAccess := GetResourceAccess(accessOp)
        if _, exists := dag.ResourceAccessMap[resourceAccess]; !exists </span><span class="cov8" title="1">{
                dag.ResourceAccessMap[resourceAccess] = make(ResourceIdentifierNodeIDMapping)
        }</span>
        <span class="cov8" title="1">dag.ResourceAccessMap[resourceAccess][accessOp.IdentifierTemplate] = append(dag.ResourceAccessMap[resourceAccess][accessOp.IdentifierTemplate], dagNode.NodeID)</span>
}

func getAllNodeIDsFromIdentifierMapping(mapping ResourceIdentifierNodeIDMapping) (allNodeIDs []DagNodeID) <span class="cov8" title="1">{
        for _, nodeIDs := range mapping </span><span class="cov8" title="1">{
                allNodeIDs = append(allNodeIDs, nodeIDs...)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (dag *Dag) getDependencyWrites(node DagNode, dependentResource acltypes.ResourceType) mapset.Set <span class="cov8" title="1">{
        nodeIDs := mapset.NewSet()
        writeResourceAccess := ResourceAccess{
                dependentResource,
                acltypes.AccessType_WRITE,
        }
        if identifierNodeMapping, ok := dag.ResourceAccessMap[writeResourceAccess]; ok </span><span class="cov8" title="1">{
                var nodeIDsMaybeDependency []DagNodeID
                if dependentResource != node.AccessOperation.ResourceType </span><span class="cov8" title="1">{
                        // we can add all node IDs as dependencies if applicable
                        nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                }</span> else<span class="cov8" title="1"> {
                        if node.AccessOperation.IdentifierTemplate != "*" </span><span class="cov8" title="1">{
                                nodeIDsMaybeDependency = identifierNodeMapping[node.AccessOperation.IdentifierTemplate]
                                nodeIDsMaybeDependency = append(nodeIDsMaybeDependency, identifierNodeMapping["*"]...)
                        }</span> else<span class="cov8" title="1"> {
                                nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                        }</span>
                }
                <span class="cov8" title="1">for _, wn := range nodeIDsMaybeDependency </span><span class="cov8" title="1">{
                        writeNode := dag.NodeMap[wn]
                        // if accessOp exists already (and from a previous transaction), we need to define a dependency on the previous message (and make a edge between the two)
                        // if from a previous transaction, we need to create an edge
                        if writeNode.TxIndex &lt; node.TxIndex </span><span class="cov8" title="1">{
                                // this should be the COMMIT access op for the tx
                                lastTxNode := dag.NodeMap[dag.TxIndexMap[writeNode.TxIndex]]
                                nodeIDs.Add(lastTxNode.NodeID)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nodeIDs</span>
}

func (dag *Dag) getDependencyUnknowns(node DagNode, dependentResource acltypes.ResourceType) mapset.Set <span class="cov8" title="1">{
        nodeIDs := mapset.NewSet()
        unknownResourceAccess := ResourceAccess{
                dependentResource,
                acltypes.AccessType_UNKNOWN,
        }
        if identifierNodeMapping, ok := dag.ResourceAccessMap[unknownResourceAccess]; ok </span><span class="cov0" title="0">{
                var nodeIDsMaybeDependency []DagNodeID
                if dependentResource != node.AccessOperation.ResourceType </span><span class="cov0" title="0">{
                        // we can add all node IDs as dependencies if applicable
                        nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                }</span> else<span class="cov0" title="0"> {
                        if node.AccessOperation.IdentifierTemplate != "*" </span><span class="cov0" title="0">{
                                nodeIDsMaybeDependency = identifierNodeMapping[node.AccessOperation.IdentifierTemplate]
                                nodeIDsMaybeDependency = append(nodeIDsMaybeDependency, identifierNodeMapping["*"]...)
                        }</span> else<span class="cov0" title="0"> {
                                nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                        }</span>
                }
                <span class="cov0" title="0">for _, un := range nodeIDsMaybeDependency </span><span class="cov0" title="0">{
                        uNode := dag.NodeMap[un]
                        // if accessOp exists already (and from a previous transaction), we need to define a dependency on the previous message (and make a edge between the two)
                        // if from a previous transaction, we need to create an edge
                        if uNode.TxIndex &lt; node.TxIndex </span><span class="cov0" title="0">{
                                // this should be the COMMIT access op for the tx
                                lastTxNode := dag.NodeMap[dag.TxIndexMap[uNode.TxIndex]]
                                nodeIDs.Add(lastTxNode.NodeID)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nodeIDs</span>
}

func (dag *Dag) getDependencyReads(node DagNode, dependentResource acltypes.ResourceType) mapset.Set <span class="cov8" title="1">{
        nodeIDs := mapset.NewSet()
        readResourceAccess := ResourceAccess{
                dependentResource,
                acltypes.AccessType_READ,
        }
        if identifierNodeMapping, ok := dag.ResourceAccessMap[readResourceAccess]; ok </span><span class="cov8" title="1">{
                var nodeIDsMaybeDependency []DagNodeID
                if dependentResource != node.AccessOperation.ResourceType </span><span class="cov8" title="1">{
                        // we can add all node IDs as dependencies if applicable
                        nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                }</span> else<span class="cov8" title="1"> {
                        if node.AccessOperation.IdentifierTemplate != "*" </span><span class="cov8" title="1">{
                                nodeIDsMaybeDependency = identifierNodeMapping[node.AccessOperation.IdentifierTemplate]
                                nodeIDsMaybeDependency = append(nodeIDsMaybeDependency, identifierNodeMapping["*"]...)
                        }</span> else<span class="cov0" title="0"> {
                                nodeIDsMaybeDependency = getAllNodeIDsFromIdentifierMapping(identifierNodeMapping)
                        }</span>
                }
                <span class="cov8" title="1">for _, rn := range nodeIDsMaybeDependency </span><span class="cov8" title="1">{
                        readNode := dag.NodeMap[rn]
                        // if from a previous transaction, we need to create an edge
                        if readNode.TxIndex &lt; node.TxIndex </span><span class="cov8" title="1">{
                                nodeIDs.Add(readNode.NodeID)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nodeIDs</span>
}

// given a node, and a dependent Resource, generate a set of nodes that are dependencies
func (dag *Dag) getNodeDependenciesForResource(node DagNode, dependentResource acltypes.ResourceType) mapset.Set <span class="cov8" title="1">{
        nodeIDs := mapset.NewSet()
        switch node.AccessOperation.AccessType </span>{
        case acltypes.AccessType_READ:<span class="cov8" title="1">
                // for a read, we are blocked on prior writes and unknown
                nodeIDs = nodeIDs.Union(dag.getDependencyWrites(node, dependentResource))
                nodeIDs = nodeIDs.Union(dag.getDependencyUnknowns(node, dependentResource))</span>
        case acltypes.AccessType_WRITE, acltypes.AccessType_UNKNOWN:<span class="cov8" title="1">
                // for write / unknown, we're blocked on prior writes, reads, and unknowns
                nodeIDs = nodeIDs.Union(dag.getDependencyWrites(node, dependentResource))
                nodeIDs = nodeIDs.Union(dag.getDependencyUnknowns(node, dependentResource))
                nodeIDs = nodeIDs.Union(dag.getDependencyReads(node, dependentResource))</span>
        }
        <span class="cov8" title="1">return nodeIDs</span>
}

// This helper will identify nodes that are dependencies for the current node, and can then be used for creating edges between then for future completion signals
func (dag *Dag) GetNodeDependencies(node DagNode) []DagNodeID <span class="cov8" title="1">{
        accessOp := node.AccessOperation
        // get all parent resource types, we'll need to create edges for any of these
        parentResources := accessOp.ResourceType.GetResourceDependencies()
        nodeIDSet := mapset.NewSet()
        for _, resource := range parentResources </span><span class="cov8" title="1">{
                nodeIDSet = nodeIDSet.Union(dag.getNodeDependenciesForResource(node, resource))
        }</span>
        <span class="cov8" title="1">nodeDependencies := make([]DagNodeID, nodeIDSet.Cardinality())
        for i, x := range nodeIDSet.ToSlice() </span><span class="cov8" title="1">{
                nodeDependencies[i] = x.(DagNodeID)
        }</span>
        <span class="cov8" title="1">return nodeDependencies</span>
}

func (dag *Dag) AddCompletionSignal(completionSignal CompletionSignal) <span class="cov8" title="1">{
        toNode := dag.NodeMap[completionSignal.ToNodeID]
        if _, exists := dag.BlockingSignalsMap[toNode.TxIndex]; !exists </span><span class="cov8" title="1">{
                dag.BlockingSignalsMap[toNode.TxIndex] = make(MessageCompletionSignalMapping)
        }</span>
        <span class="cov8" title="1">if _, exists := dag.BlockingSignalsMap[toNode.TxIndex][toNode.MessageIndex]; !exists </span><span class="cov8" title="1">{
                dag.BlockingSignalsMap[toNode.TxIndex][toNode.MessageIndex] = make(map[acltypes.AccessOperation][]CompletionSignal)
        }</span>
        // add it to the right blocking signal in the right txindex
        <span class="cov8" title="1">prevBlockSignalMapping := dag.BlockingSignalsMap[toNode.TxIndex][toNode.MessageIndex][completionSignal.BlockedAccessOperation]
        dag.BlockingSignalsMap[toNode.TxIndex][toNode.MessageIndex][completionSignal.BlockedAccessOperation] = append(prevBlockSignalMapping, completionSignal)

        fromNode := dag.NodeMap[completionSignal.FromNodeID]
        if _, exists := dag.CompletionSignalingMap[fromNode.TxIndex]; !exists </span><span class="cov8" title="1">{
                dag.CompletionSignalingMap[fromNode.TxIndex] = make(MessageCompletionSignalMapping)
        }</span>
        <span class="cov8" title="1">if _, exists := dag.CompletionSignalingMap[fromNode.TxIndex][fromNode.MessageIndex]; !exists </span><span class="cov8" title="1">{
                dag.CompletionSignalingMap[fromNode.TxIndex][fromNode.MessageIndex] = make(map[acltypes.AccessOperation][]CompletionSignal)
        }</span>
        // add it to the completion signal for the tx index
        <span class="cov8" title="1">prevCompletionSignalMapping := dag.CompletionSignalingMap[fromNode.TxIndex][fromNode.MessageIndex][completionSignal.CompletionAccessOperation]
        dag.CompletionSignalingMap[fromNode.TxIndex][fromNode.MessageIndex][completionSignal.CompletionAccessOperation] = append(prevCompletionSignalMapping, completionSignal)</span>
}

func IsGovMessage(msg sdk.Msg) bool <span class="cov0" title="0">{
        switch msg.(type) </span>{
        case *govtypes.MsgVoteWeighted, *govtypes.MsgVote, *govtypes.MsgSubmitProposal, *govtypes.MsgDeposit:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/address"
)

// ResourceDependencyMappingKey is the key used for the keeper store
var (
        ResourceDependencyMappingKey = 0x01
        WasmMappingKey               = 0x02
)

const (
        // ModuleName defines the module name
        ModuleName = "accesscontrol"

        QuerierRoute = ModuleName

        // Append "acl" to prevent prefix collision with "acc" module
        StoreKey = "acl" + ModuleName

        RouterKey = ModuleName
)

func GetResourceDependencyMappingKey() []byte <span class="cov0" title="0">{
        return []byte{byte(ResourceDependencyMappingKey)}
}</span>

func GetResourceDependencyKey(messageKey MessageKey) []byte <span class="cov0" title="0">{
        return append(GetResourceDependencyMappingKey(), []byte(messageKey)...)
}</span>

func GetWasmMappingKey() []byte <span class="cov8" title="1">{
        return []byte{byte(WasmMappingKey)}
}</span>

func GetWasmContractAddressKey(contractAddress sdk.AccAddress) []byte <span class="cov0" title="0">{
        return append(GetWasmMappingKey(), address.MustLengthPrefix(contractAddress)...)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import (
        fmt "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/gogo/protobuf/proto"
)

var (
        ErrNoCommitAccessOp                  = fmt.Errorf("MessageDependencyMapping doesn't terminate with AccessType_COMMIT")
        ErrEmptyIdentifierString             = fmt.Errorf("IdentifierTemplate cannot be an empty string")
        ErrNonLeafResourceTypeWithIdentifier = fmt.Errorf("IdentifierTemplate must be '*' for non leaf resource types")
        ErrDuplicateWasmMethodName           = fmt.Errorf("a method name is defined multiple times in specific access operation list")
        ErrQueryRefNonQueryMessageType       = fmt.Errorf("query contract references can only have query message types")
        ErrSelectorDeprecated                = fmt.Errorf("this selector type is deprecated")
        ErrInvalidMsgInfo                    = fmt.Errorf("msg info cannot be nil")
)

type MessageKey string

func GenerateMessageKey(msg sdk.Msg) MessageKey <span class="cov8" title="1">{
        return MessageKey(proto.MessageName(msg))
}</span>

func CommitAccessOp() *acltypes.AccessOperation <span class="cov8" title="1">{
        return &amp;acltypes.AccessOperation{ResourceType: acltypes.ResourceType_ANY, AccessType: acltypes.AccessType_COMMIT, IdentifierTemplate: "*"}
}</span>

// Validates access operation sequence for a message, requires the last access operation to be a COMMIT
func ValidateAccessOps(accessOps []acltypes.AccessOperation) error <span class="cov0" title="0">{
        lastAccessOp := accessOps[len(accessOps)-1]
        if lastAccessOp != *CommitAccessOp() </span><span class="cov0" title="0">{
                return ErrNoCommitAccessOp
        }</span>
        <span class="cov0" title="0">for _, accessOp := range accessOps </span><span class="cov0" title="0">{
                err := ValidateAccessOp(accessOp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateAccessOp(accessOp acltypes.AccessOperation) error <span class="cov0" title="0">{
        if accessOp.IdentifierTemplate == "" </span><span class="cov0" title="0">{
                return ErrEmptyIdentifierString
        }</span>
        <span class="cov0" title="0">if accessOp.ResourceType.HasChildren() &amp;&amp; accessOp.IdentifierTemplate != "*" </span><span class="cov0" title="0">{
                return ErrNonLeafResourceTypeWithIdentifier
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateMessageDependencyMapping(mapping acltypes.MessageDependencyMapping) error <span class="cov0" title="0">{
        return ValidateAccessOps(mapping.AccessOps)
}</span>

func SynchronousMessageDependencyMapping(messageKey MessageKey) acltypes.MessageDependencyMapping <span class="cov0" title="0">{
        return acltypes.MessageDependencyMapping{
                MessageKey:     string(messageKey),
                DynamicEnabled: true,
                AccessOps:      acltypes.SynchronousAccessOps(),
        }
}</span>

func SynchronousAccessOps() []acltypes.AccessOperation <span class="cov0" title="0">{
        return []acltypes.AccessOperation{
                {AccessType: acltypes.AccessType_UNKNOWN, ResourceType: acltypes.ResourceType_ANY, IdentifierTemplate: "*"},
                *CommitAccessOp(),
        }
}</span>

func SynchronousWasmAccessOps() []*acltypes.WasmAccessOperation <span class="cov0" title="0">{
        return []*acltypes.WasmAccessOperation{
                {
                        Operation:    &amp;acltypes.AccessOperation{AccessType: acltypes.AccessType_UNKNOWN, ResourceType: acltypes.ResourceType_ANY, IdentifierTemplate: "*"},
                        SelectorType: acltypes.AccessOperationSelectorType_NONE,
                },
                {
                        Operation:    CommitAccessOp(),
                        SelectorType: acltypes.AccessOperationSelectorType_NONE,
                },
        }
}</span>

func SynchronousAccessOpsSet() *AccessOperationSet <span class="cov0" title="0">{
        return NewAccessOperationSet(SynchronousAccessOps())
}</span>

func SynchronousWasmDependencyMapping(contractAddress string) acltypes.WasmDependencyMapping <span class="cov0" title="0">{
        return acltypes.WasmDependencyMapping{
                BaseAccessOps:   SynchronousWasmAccessOps(),
                ContractAddress: contractAddress,
        }
}</span>

func IsDefaultSynchronousWasmAccessOps(accessOps []*acltypes.WasmAccessOperation) bool <span class="cov0" title="0">{
        defaultAccessOps := SynchronousWasmAccessOps()
        for index, accessOp := range accessOps </span><span class="cov0" title="0">{
                if *accessOp != *defaultAccessOps[index] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func IsCommitOp(accessOp *acltypes.AccessOperation) bool <span class="cov0" title="0">{
        return accessOp.AccessType == acltypes.AccessType_COMMIT
}</span>

func DefaultMessageDependencyMapping() []acltypes.MessageDependencyMapping <span class="cov8" title="1">{
        return []acltypes.MessageDependencyMapping{}
}</span>

func DefaultWasmDependencyMappings() []acltypes.WasmDependencyMapping <span class="cov8" title="1">{
        return []acltypes.WasmDependencyMapping{}
}</span>

// Base access operation list must end with access type commit
func ValidateWasmDependencyMapping(mapping acltypes.WasmDependencyMapping) error <span class="cov8" title="1">{
        numOps := len(mapping.BaseAccessOps)
        if numOps == 0 || mapping.BaseAccessOps[numOps-1].Operation.AccessType != acltypes.AccessType_COMMIT </span><span class="cov0" title="0">{
                return ErrNoCommitAccessOp
        }</span>

        // ensure uniqueness for partitioned message names across access ops and contract references
        <span class="cov8" title="1">seenMessageNames := map[string]struct{}{}
        for _, ops := range mapping.ExecuteAccessOps </span><span class="cov8" title="1">{
                if _, ok := seenMessageNames[ops.MessageName]; ok </span><span class="cov0" title="0">{
                        return ErrDuplicateWasmMethodName
                }</span>
                <span class="cov8" title="1">seenMessageNames[ops.MessageName] = struct{}{}</span>
        }
        <span class="cov8" title="1">seenMessageNames = map[string]struct{}{}
        for _, ops := range mapping.QueryAccessOps </span><span class="cov8" title="1">{
                if _, ok := seenMessageNames[ops.MessageName]; ok </span><span class="cov0" title="0">{
                        return ErrDuplicateWasmMethodName
                }</span>
                <span class="cov8" title="1">seenMessageNames[ops.MessageName] = struct{}{}</span>
        }
        <span class="cov8" title="1">seenMessageNames = map[string]struct{}{}
        for _, ops := range mapping.ExecuteContractReferences </span><span class="cov8" title="1">{
                if _, ok := seenMessageNames[ops.MessageName]; ok </span><span class="cov8" title="1">{
                        return ErrDuplicateWasmMethodName
                }</span>
                <span class="cov8" title="1">seenMessageNames[ops.MessageName] = struct{}{}</span>
        }
        <span class="cov8" title="1">seenMessageNames = map[string]struct{}{}
        for _, ops := range mapping.QueryContractReferences </span><span class="cov8" title="1">{
                if _, ok := seenMessageNames[ops.MessageName]; ok </span><span class="cov8" title="1">{
                        return ErrDuplicateWasmMethodName
                }</span>
                <span class="cov8" title="1">seenMessageNames[ops.MessageName] = struct{}{}</span>
        }

        // ensure deprecation for CONTRACT_REFERENCE access operation selector due to new contract references
        <span class="cov8" title="1">for _, accessOp := range mapping.BaseAccessOps </span><span class="cov8" title="1">{
                if accessOp.SelectorType == acltypes.AccessOperationSelectorType_CONTRACT_REFERENCE </span><span class="cov8" title="1">{
                        return ErrSelectorDeprecated
                }</span>
        }
        <span class="cov8" title="1">for _, accessOps := range mapping.ExecuteAccessOps </span><span class="cov8" title="1">{
                for _, accessOp := range accessOps.WasmOperations </span><span class="cov8" title="1">{
                        if accessOp.SelectorType == acltypes.AccessOperationSelectorType_CONTRACT_REFERENCE </span><span class="cov8" title="1">{
                                return ErrSelectorDeprecated
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, accessOps := range mapping.QueryAccessOps </span><span class="cov8" title="1">{
                for _, accessOp := range accessOps.WasmOperations </span><span class="cov8" title="1">{
                        if accessOp.SelectorType == acltypes.AccessOperationSelectorType_CONTRACT_REFERENCE </span><span class="cov8" title="1">{
                                return ErrSelectorDeprecated
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

const (
        TypeMsgRegisterWasmDependency = "register_wasm_dependency"
)

var (
        _ sdk.Msg = &amp;MsgRegisterWasmDependency{}
)

func NewMsgRegisterWasmDependencyFromJSON(fromAddr sdk.AccAddress, jsonFile RegisterWasmDependencyJSONFile) *MsgRegisterWasmDependency <span class="cov0" title="0">{
        m := &amp;MsgRegisterWasmDependency{
                FromAddress:           fromAddr.String(),
                WasmDependencyMapping: jsonFile.WasmDependencyMapping,
        }
        return m
}</span>

func NewMsgRegisterWasmDependency(fromAddr sdk.AccAddress, contractAddr sdk.AccAddress, wasmDependencyMapping acltypes.WasmDependencyMapping) *MsgRegisterWasmDependency <span class="cov0" title="0">{
        m := &amp;MsgRegisterWasmDependency{
                FromAddress:           fromAddr.String(),
                WasmDependencyMapping: wasmDependencyMapping,
        }
        return m
}</span>

// Route implements Msg
func (m MsgRegisterWasmDependency) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

// Type implements Msg
func (m MsgRegisterWasmDependency) Type() string <span class="cov0" title="0">{ return TypeMsgRegisterWasmDependency }</span>

// ValidateBasic implements Msg
func (m MsgRegisterWasmDependency) ValidateBasic() error <span class="cov0" title="0">{
        if m.FromAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, m.FromAddress)
        }</span>

        <span class="cov0" title="0">if m.WasmDependencyMapping.ContractAddress == "" </span><span class="cov0" title="0">{
                return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, m.WasmDependencyMapping.ContractAddress)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSignBytes implements Msg
func (m MsgRegisterWasmDependency) GetSignBytes() []byte <span class="cov0" title="0">{
        bz := ModuleCdc.MustMarshalJSON(&amp;m)
        return sdk.MustSortJSON(bz)
}</span>

// GetSigners implements Msg
func (m MsgRegisterWasmDependency) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        fromAddr, _ := sdk.AccAddressFromBech32(m.FromAddress)
        return []sdk.AccAddress{fromAddr}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package types

import (
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "gopkg.in/yaml.v2"
)

func ParamKeyTable() paramtypes.KeyTable <span class="cov8" title="1">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

func (p Params) String() string <span class="cov0" title="0">{
        out, _ := yaml.Marshal(p)
        return string(out)
}</span>

func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov8" title="1">{
        return paramtypes.ParamSetPairs{}
}</span>

func NewParams() Params <span class="cov8" title="1">{
        return Params{}
}</span>

// default access control module parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams()
}</span>

func (p Params) Validate() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accesscontrol_x/query.proto

package types

import (
        context "context"
        fmt "fmt"
        accesscontrol "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{0}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

type QueryParamsResponse struct {
        // params defines the parameters of the module.
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{1}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

type ResourceDependencyMappingFromMessageKeyRequest struct {
        MessageKey string `protobuf:"bytes,1,opt,name=message_key,json=messageKey,proto3" json:"message_key,omitempty" yaml:"message_key"`
}

func (m *ResourceDependencyMappingFromMessageKeyRequest) Reset() <span class="cov0" title="0">{
        *m = ResourceDependencyMappingFromMessageKeyRequest{}
}</span>
func (m *ResourceDependencyMappingFromMessageKeyRequest) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*ResourceDependencyMappingFromMessageKeyRequest) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*ResourceDependencyMappingFromMessageKeyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{2}
}</span>
func (m *ResourceDependencyMappingFromMessageKeyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ResourceDependencyMappingFromMessageKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ResourceDependencyMappingFromMessageKeyRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ResourceDependencyMappingFromMessageKeyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ResourceDependencyMappingFromMessageKeyRequest.Merge(m, src)
}</span>
func (m *ResourceDependencyMappingFromMessageKeyRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ResourceDependencyMappingFromMessageKeyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ResourceDependencyMappingFromMessageKeyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ResourceDependencyMappingFromMessageKeyRequest proto.InternalMessageInfo

func (m *ResourceDependencyMappingFromMessageKeyRequest) GetMessageKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MessageKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ResourceDependencyMappingFromMessageKeyResponse struct {
        MessageDependencyMapping accesscontrol.MessageDependencyMapping `protobuf:"bytes,1,opt,name=message_dependency_mapping,json=messageDependencyMapping,proto3" json:"message_dependency_mapping" yaml:"message_dependency_mapping"`
}

func (m *ResourceDependencyMappingFromMessageKeyResponse) Reset() <span class="cov0" title="0">{
        *m = ResourceDependencyMappingFromMessageKeyResponse{}
}</span>
func (m *ResourceDependencyMappingFromMessageKeyResponse) String() string <span class="cov0" title="0">{
        return proto.CompactTextString(m)
}</span>
func (*ResourceDependencyMappingFromMessageKeyResponse) ProtoMessage() {<span class="cov0" title="0">}</span>
func (*ResourceDependencyMappingFromMessageKeyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{3}
}</span>
func (m *ResourceDependencyMappingFromMessageKeyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ResourceDependencyMappingFromMessageKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ResourceDependencyMappingFromMessageKeyResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ResourceDependencyMappingFromMessageKeyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ResourceDependencyMappingFromMessageKeyResponse.Merge(m, src)
}</span>
func (m *ResourceDependencyMappingFromMessageKeyResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ResourceDependencyMappingFromMessageKeyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ResourceDependencyMappingFromMessageKeyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ResourceDependencyMappingFromMessageKeyResponse proto.InternalMessageInfo

func (m *ResourceDependencyMappingFromMessageKeyResponse) GetMessageDependencyMapping() accesscontrol.MessageDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MessageDependencyMapping
        }</span>
        <span class="cov0" title="0">return accesscontrol.MessageDependencyMapping{}</span>
}

type WasmDependencyMappingRequest struct {
        ContractAddress string `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty" yaml:"contract_address"`
}

func (m *WasmDependencyMappingRequest) Reset()         <span class="cov0" title="0">{ *m = WasmDependencyMappingRequest{} }</span>
func (m *WasmDependencyMappingRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*WasmDependencyMappingRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*WasmDependencyMappingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{4}
}</span>
func (m *WasmDependencyMappingRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *WasmDependencyMappingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_WasmDependencyMappingRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *WasmDependencyMappingRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_WasmDependencyMappingRequest.Merge(m, src)
}</span>
func (m *WasmDependencyMappingRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *WasmDependencyMappingRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_WasmDependencyMappingRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_WasmDependencyMappingRequest proto.InternalMessageInfo

func (m *WasmDependencyMappingRequest) GetContractAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContractAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type WasmDependencyMappingResponse struct {
        WasmDependencyMapping accesscontrol.WasmDependencyMapping `protobuf:"bytes,1,opt,name=wasm_dependency_mapping,json=wasmDependencyMapping,proto3" json:"wasm_dependency_mapping" yaml:"wasm_dependency_mapping"`
}

func (m *WasmDependencyMappingResponse) Reset()         <span class="cov0" title="0">{ *m = WasmDependencyMappingResponse{} }</span>
func (m *WasmDependencyMappingResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*WasmDependencyMappingResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*WasmDependencyMappingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{5}
}</span>
func (m *WasmDependencyMappingResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *WasmDependencyMappingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_WasmDependencyMappingResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *WasmDependencyMappingResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_WasmDependencyMappingResponse.Merge(m, src)
}</span>
func (m *WasmDependencyMappingResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *WasmDependencyMappingResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_WasmDependencyMappingResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_WasmDependencyMappingResponse proto.InternalMessageInfo

func (m *WasmDependencyMappingResponse) GetWasmDependencyMapping() accesscontrol.WasmDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WasmDependencyMapping
        }</span>
        <span class="cov0" title="0">return accesscontrol.WasmDependencyMapping{}</span>
}

type ListResourceDependencyMappingRequest struct {
}

func (m *ListResourceDependencyMappingRequest) Reset()         <span class="cov0" title="0">{ *m = ListResourceDependencyMappingRequest{} }</span>
func (m *ListResourceDependencyMappingRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListResourceDependencyMappingRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListResourceDependencyMappingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{6}
}</span>
func (m *ListResourceDependencyMappingRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListResourceDependencyMappingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListResourceDependencyMappingRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListResourceDependencyMappingRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListResourceDependencyMappingRequest.Merge(m, src)
}</span>
func (m *ListResourceDependencyMappingRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListResourceDependencyMappingRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListResourceDependencyMappingRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListResourceDependencyMappingRequest proto.InternalMessageInfo

type ListResourceDependencyMappingResponse struct {
        MessageDependencyMappingList []accesscontrol.MessageDependencyMapping `protobuf:"bytes,1,rep,name=message_dependency_mapping_list,json=messageDependencyMappingList,proto3" json:"message_dependency_mapping_list" yaml:"message_dependency_mapping_list"`
}

func (m *ListResourceDependencyMappingResponse) Reset()         <span class="cov0" title="0">{ *m = ListResourceDependencyMappingResponse{} }</span>
func (m *ListResourceDependencyMappingResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListResourceDependencyMappingResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListResourceDependencyMappingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{7}
}</span>
func (m *ListResourceDependencyMappingResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListResourceDependencyMappingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListResourceDependencyMappingResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListResourceDependencyMappingResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListResourceDependencyMappingResponse.Merge(m, src)
}</span>
func (m *ListResourceDependencyMappingResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListResourceDependencyMappingResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListResourceDependencyMappingResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListResourceDependencyMappingResponse proto.InternalMessageInfo

func (m *ListResourceDependencyMappingResponse) GetMessageDependencyMappingList() []accesscontrol.MessageDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MessageDependencyMappingList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListWasmDependencyMappingRequest struct {
}

func (m *ListWasmDependencyMappingRequest) Reset()         <span class="cov0" title="0">{ *m = ListWasmDependencyMappingRequest{} }</span>
func (m *ListWasmDependencyMappingRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListWasmDependencyMappingRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListWasmDependencyMappingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{8}
}</span>
func (m *ListWasmDependencyMappingRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListWasmDependencyMappingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListWasmDependencyMappingRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListWasmDependencyMappingRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListWasmDependencyMappingRequest.Merge(m, src)
}</span>
func (m *ListWasmDependencyMappingRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListWasmDependencyMappingRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListWasmDependencyMappingRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListWasmDependencyMappingRequest proto.InternalMessageInfo

type ListWasmDependencyMappingResponse struct {
        WasmDependencyMappingList []accesscontrol.WasmDependencyMapping `protobuf:"bytes,1,rep,name=wasm_dependency_mapping_list,json=wasmDependencyMappingList,proto3" json:"wasm_dependency_mapping_list" yaml:"wasm_dependency_mapping_list"`
}

func (m *ListWasmDependencyMappingResponse) Reset()         <span class="cov0" title="0">{ *m = ListWasmDependencyMappingResponse{} }</span>
func (m *ListWasmDependencyMappingResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListWasmDependencyMappingResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListWasmDependencyMappingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d83f2274e13e6a16, []int{9}
}</span>
func (m *ListWasmDependencyMappingResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *ListWasmDependencyMappingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_ListWasmDependencyMappingResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *ListWasmDependencyMappingResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListWasmDependencyMappingResponse.Merge(m, src)
}</span>
func (m *ListWasmDependencyMappingResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *ListWasmDependencyMappingResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListWasmDependencyMappingResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListWasmDependencyMappingResponse proto.InternalMessageInfo

func (m *ListWasmDependencyMappingResponse) GetWasmDependencyMappingList() []accesscontrol.WasmDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WasmDependencyMappingList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryParamsRequest)(nil), "cosmos.accesscontrol_x.v1beta1.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "cosmos.accesscontrol_x.v1beta1.QueryParamsResponse")
        proto.RegisterType((*ResourceDependencyMappingFromMessageKeyRequest)(nil), "cosmos.accesscontrol_x.v1beta1.ResourceDependencyMappingFromMessageKeyRequest")
        proto.RegisterType((*ResourceDependencyMappingFromMessageKeyResponse)(nil), "cosmos.accesscontrol_x.v1beta1.ResourceDependencyMappingFromMessageKeyResponse")
        proto.RegisterType((*WasmDependencyMappingRequest)(nil), "cosmos.accesscontrol_x.v1beta1.WasmDependencyMappingRequest")
        proto.RegisterType((*WasmDependencyMappingResponse)(nil), "cosmos.accesscontrol_x.v1beta1.WasmDependencyMappingResponse")
        proto.RegisterType((*ListResourceDependencyMappingRequest)(nil), "cosmos.accesscontrol_x.v1beta1.ListResourceDependencyMappingRequest")
        proto.RegisterType((*ListResourceDependencyMappingResponse)(nil), "cosmos.accesscontrol_x.v1beta1.ListResourceDependencyMappingResponse")
        proto.RegisterType((*ListWasmDependencyMappingRequest)(nil), "cosmos.accesscontrol_x.v1beta1.ListWasmDependencyMappingRequest")
        proto.RegisterType((*ListWasmDependencyMappingResponse)(nil), "cosmos.accesscontrol_x.v1beta1.ListWasmDependencyMappingResponse")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("cosmos/accesscontrol_x/query.proto", fileDescriptor_d83f2274e13e6a16)
}</span>

var fileDescriptor_d83f2274e13e6a16 = []byte{
        // 781 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x4f, 0x13, 0x4d,
        0x18, 0xee, 0xf0, 0x7d, 0x1f, 0x09, 0xc3, 0xe1, 0x33, 0x23, 0x08, 0xd4, 0xb2, 0x85, 0x11, 0x0b,
        0x68, 0xdc, 0x0d, 0x25, 0xd1, 0xc4, 0x48, 0x94, 0x0a, 0x24, 0x06, 0xf0, 0xc7, 0x7a, 0x30, 0x91,
        0x98, 0x66, 0xba, 0x1d, 0xd6, 0x0d, 0xdd, 0x9d, 0x65, 0x67, 0x2b, 0x34, 0x84, 0x8b, 0x7f, 0x81,
        0x09, 0x7f, 0x80, 0xd1, 0xbb, 0x7a, 0xf2, 0x6f, 0x90, 0x23, 0x09, 0x07, 0x3d, 0x35, 0x06, 0x4c,
        0x8c, 0x57, 0x2e, 0x5e, 0xcd, 0xee, 0x4e, 0x49, 0x69, 0xf7, 0x47, 0x01, 0x4f, 0xcb, 0xce, 0xbe,
        0xef, 0xfb, 0xbc, 0xcf, 0xf3, 0xbe, 0xf3, 0x50, 0x88, 0x35, 0xc6, 0x4d, 0xc6, 0x15, 0xa2, 0x69,
        0x94, 0x73, 0x8d, 0x59, 0xae, 0xc3, 0x2a, 0xc5, 0x4d, 0x65, 0xbd, 0x4a, 0x9d, 0x9a, 0x6c, 0x3b,
        0xcc, 0x65, 0x48, 0x0a, 0x62, 0xe4, 0x96, 0x18, 0xf9, 0xd5, 0x54, 0x89, 0xba, 0x64, 0x2a, 0xdd,
        0xa7, 0x33, 0x9d, 0xf9, 0xa1, 0x8a, 0xf7, 0x57, 0x90, 0x95, 0xce, 0xe8, 0x8c, 0xe9, 0x15, 0xaa,
        0x10, 0xdb, 0x50, 0x88, 0x65, 0x31, 0x97, 0xb8, 0x06, 0xb3, 0xb8, 0xf8, 0x7a, 0x4d, 0xe0, 0x96,
        0x08, 0xa7, 0x01, 0x98, 0x22, 0xca, 0x29, 0x36, 0xd1, 0x0d, 0xcb, 0x0f, 0x16, 0xb1, 0x13, 0x61,
        0x3d, 0x9e, 0x7c, 0x13, 0x91, 0x63, 0x11, 0x6c, 0x74, 0x6a, 0x51, 0x6e, 0x08, 0x6c, 0xdc, 0x07,
        0xd1, 0x13, 0x0f, 0xf1, 0x31, 0x71, 0x88, 0xc9, 0x55, 0xba, 0x5e, 0xa5, 0xdc, 0xc5, 0x2b, 0xf0,
        0xe2, 0x89, 0x53, 0x6e, 0x33, 0x8b, 0x53, 0x34, 0x07, 0xbb, 0x6d, 0xff, 0x64, 0x10, 0x8c, 0x80,
        0x89, 0xde, 0x7c, 0x4e, 0x8e, 0x57, 0x43, 0x0e, 0xf2, 0x0b, 0xff, 0xee, 0xd6, 0xb3, 0x29, 0x55,
        0xe4, 0x62, 0x03, 0xca, 0x2a, 0xe5, 0xac, 0xea, 0x68, 0x74, 0x8e, 0xda, 0xd4, 0x2a, 0x53, 0x4b,
        0xab, 0x2d, 0x13, 0xdb, 0x36, 0x2c, 0x7d, 0xc1, 0x61, 0xe6, 0x32, 0xe5, 0x9c, 0xe8, 0x74, 0x91,
        0xd6, 0x44, 0x3b, 0xe8, 0x16, 0xec, 0x35, 0x83, 0xc3, 0xe2, 0x1a, 0xad, 0xf9, 0xe0, 0x3d, 0x85,
        0x4b, 0x47, 0xf5, 0x2c, 0xaa, 0x11, 0xb3, 0x72, 0x1b, 0x37, 0x7d, 0xc4, 0x2a, 0x34, 0x8f, 0xf3,
        0xf1, 0x3e, 0x80, 0x4a, 0xc7, 0x58, 0x82, 0xe4, 0x5b, 0x00, 0xd3, 0x8d, 0x82, 0xe5, 0xe3, 0x9c,
        0xa2, 0x19, 0x24, 0x09, 0xe6, 0x37, 0x43, 0x99, 0x1f, 0xf3, 0x16, 0x65, 0xdb, 0x20, 0x0b, 0x93,
        0x9e, 0x12, 0x47, 0xf5, 0xec, 0xe8, 0xc9, 0xc6, 0xdb, 0x71, 0xb0, 0x3a, 0x68, 0x46, 0x14, 0xc1,
        0xab, 0x30, 0xf3, 0x8c, 0x70, 0xb3, 0xed, 0x43, 0x43, 0xae, 0x05, 0x78, 0xc1, 0x6f, 0x88, 0x68,
        0x6e, 0x91, 0x94, 0xcb, 0x0e, 0xe5, 0x5c, 0x68, 0x76, 0xf9, 0xa8, 0x9e, 0x1d, 0x08, 0xa0, 0x5b,
        0x23, 0xb0, 0xfa, 0x7f, 0xe3, 0x68, 0x56, 0x9c, 0x7c, 0x06, 0x70, 0x38, 0x02, 0x48, 0x68, 0xb5,
        0x03, 0xe0, 0xc0, 0x06, 0xe1, 0x66, 0xb4, 0x50, 0xd3, 0xf1, 0x42, 0x85, 0x96, 0x2f, 0xe4, 0x84,
        0x4a, 0x52, 0xd0, 0x6a, 0x04, 0x02, 0x56, 0xfb, 0x37, 0xc2, 0xd2, 0x71, 0x0e, 0x8e, 0x2d, 0x19,
        0xdc, 0x8d, 0x1c, 0x7c, 0x63, 0xcb, 0xbf, 0x02, 0x78, 0x35, 0x21, 0x50, 0xf0, 0xfc, 0x00, 0x60,
        0x36, 0x7a, 0x56, 0xc5, 0x8a, 0xc1, 0xdd, 0x41, 0x30, 0xf2, 0xcf, 0x39, 0x16, 0x43, 0x16, 0x94,
        0x73, 0x49, 0x8b, 0xe1, 0x83, 0x61, 0x35, 0x13, 0xb5, 0x1d, 0x1e, 0x21, 0x8c, 0xe1, 0x88, 0xf7,
        0x8c, 0xdb, 0x12, 0xfc, 0x05, 0xc0, 0xd1, 0x98, 0x20, 0xc1, 0xfc, 0x1d, 0x80, 0x99, 0x08, 0xfd,
        0x9b, 0x69, 0x9f, 0x69, 0xcc, 0xd7, 0x05, 0xe7, 0x2b, 0xb1, 0x63, 0x16, 0x84, 0x87, 0x42, 0x67,
        0xed, 0x11, 0xc8, 0x7f, 0xec, 0x81, 0xff, 0xf9, 0x76, 0x85, 0xde, 0x03, 0xd8, 0x1d, 0x78, 0x0e,
        0xca, 0x27, 0x79, 0x53, 0xbb, 0xed, 0xa5, 0xa7, 0x4f, 0x95, 0x13, 0x28, 0x84, 0x95, 0xd7, 0xfb,
        0x3f, 0x76, 0xba, 0x26, 0xd1, 0xb8, 0x22, 0x0c, 0x37, 0x78, 0xdc, 0xe0, 0xe5, 0xb5, 0x16, 0x97,
        0x0e, 0xfc, 0x0f, 0x7d, 0xea, 0x82, 0xe3, 0x1d, 0x9a, 0x12, 0x7a, 0x98, 0xd4, 0xd1, 0xe9, 0x9c,
        0x34, 0xfd, 0xe8, 0xaf, 0xd5, 0x13, 0xec, 0x35, 0x9f, 0xfd, 0x0b, 0xb4, 0x92, 0xc8, 0xde, 0x11,
        0x95, 0xc3, 0x46, 0xbc, 0xea, 0x30, 0xb3, 0xd8, 0xe4, 0xe2, 0xca, 0x56, 0xd3, 0xcb, 0x36, 0xfa,
        0x0d, 0xe0, 0x70, 0xec, 0x45, 0x45, 0x73, 0x49, 0xbc, 0x3a, 0x31, 0x84, 0xf4, 0xfc, 0x39, 0xab,
        0x08, 0x4d, 0x1e, 0xf8, 0x9a, 0xdc, 0x47, 0xb3, 0x89, 0x9a, 0x78, 0xab, 0x5d, 0x8c, 0x11, 0x06,
        0xfd, 0x02, 0xb0, 0x3f, 0xf4, 0xf2, 0xa0, 0x3b, 0x49, 0xbd, 0xc6, 0x5d, 0xfe, 0xf4, 0xcc, 0x19,
        0xb3, 0x05, 0xc3, 0xa7, 0x3e, 0xc3, 0x65, 0xb4, 0x98, 0xc8, 0x30, 0xe2, 0x52, 0x2b, 0x5b, 0xad,
        0xff, 0x7f, 0xb6, 0xd1, 0x4f, 0x00, 0x87, 0x22, 0x0d, 0x09, 0xdd, 0xeb, 0x64, 0x36, 0xb1, 0x9c,
        0x67, 0xcf, 0x51, 0x41, 0xf0, 0x9e, 0xf7, 0x79, 0xdf, 0x45, 0x33, 0x9d, 0x4d, 0x36, 0x82, 0x7c,
        0x61, 0x69, 0xf7, 0x40, 0x02, 0x7b, 0x07, 0x12, 0xf8, 0x7e, 0x20, 0x81, 0x37, 0x87, 0x52, 0x6a,
        0xef, 0x50, 0x4a, 0x7d, 0x3b, 0x94, 0x52, 0xcf, 0xf3, 0xba, 0xe1, 0xbe, 0xac, 0x96, 0x64, 0x8d,
        0x99, 0x21, 0x10, 0x9b, 0x2d, 0x20, 0x6e, 0xcd, 0xa6, 0xbc, 0xd4, 0xed, 0xff, 0x92, 0x9b, 0xfe,
        0x13, 0x00, 0x00, 0xff, 0xff, 0xe8, 0x74, 0x69, 0xa8, 0xbf, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
        Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
        ResourceDependencyMappingFromMessageKey(ctx context.Context, in *ResourceDependencyMappingFromMessageKeyRequest, opts ...grpc.CallOption) (*ResourceDependencyMappingFromMessageKeyResponse, error)
        ListResourceDependencyMapping(ctx context.Context, in *ListResourceDependencyMappingRequest, opts ...grpc.CallOption) (*ListResourceDependencyMappingResponse, error)
        WasmDependencyMapping(ctx context.Context, in *WasmDependencyMappingRequest, opts ...grpc.CallOption) (*WasmDependencyMappingResponse, error)
        ListWasmDependencyMapping(ctx context.Context, in *ListWasmDependencyMappingRequest, opts ...grpc.CallOption) (*ListWasmDependencyMappingResponse, error)
}

type queryClient struct {
        cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient <span class="cov0" title="0">{
        return &amp;queryClient{cc}
}</span>

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Query/Params", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ResourceDependencyMappingFromMessageKey(ctx context.Context, in *ResourceDependencyMappingFromMessageKeyRequest, opts ...grpc.CallOption) (*ResourceDependencyMappingFromMessageKeyResponse, error) <span class="cov0" title="0">{
        out := new(ResourceDependencyMappingFromMessageKeyResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Query/ResourceDependencyMappingFromMessageKey", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ListResourceDependencyMapping(ctx context.Context, in *ListResourceDependencyMappingRequest, opts ...grpc.CallOption) (*ListResourceDependencyMappingResponse, error) <span class="cov0" title="0">{
        out := new(ListResourceDependencyMappingResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Query/ListResourceDependencyMapping", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) WasmDependencyMapping(ctx context.Context, in *WasmDependencyMappingRequest, opts ...grpc.CallOption) (*WasmDependencyMappingResponse, error) <span class="cov0" title="0">{
        out := new(WasmDependencyMappingResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Query/WasmDependencyMapping", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryClient) ListWasmDependencyMapping(ctx context.Context, in *ListWasmDependencyMappingRequest, opts ...grpc.CallOption) (*ListWasmDependencyMappingResponse, error) <span class="cov0" title="0">{
        out := new(ListWasmDependencyMappingResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Query/ListWasmDependencyMapping", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServer is the server API for Query service.
type QueryServer interface {
        Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
        ResourceDependencyMappingFromMessageKey(context.Context, *ResourceDependencyMappingFromMessageKeyRequest) (*ResourceDependencyMappingFromMessageKeyResponse, error)
        ListResourceDependencyMapping(context.Context, *ListResourceDependencyMappingRequest) (*ListResourceDependencyMappingResponse, error)
        WasmDependencyMapping(context.Context, *WasmDependencyMappingRequest) (*WasmDependencyMappingResponse, error)
        ListWasmDependencyMapping(context.Context, *ListWasmDependencyMappingRequest) (*ListWasmDependencyMappingResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}</span>
func (*UnimplementedQueryServer) ResourceDependencyMappingFromMessageKey(ctx context.Context, req *ResourceDependencyMappingFromMessageKeyRequest) (*ResourceDependencyMappingFromMessageKeyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ResourceDependencyMappingFromMessageKey not implemented")
}</span>
func (*UnimplementedQueryServer) ListResourceDependencyMapping(ctx context.Context, req *ListResourceDependencyMappingRequest) (*ListResourceDependencyMappingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListResourceDependencyMapping not implemented")
}</span>
func (*UnimplementedQueryServer) WasmDependencyMapping(ctx context.Context, req *WasmDependencyMappingRequest) (*WasmDependencyMappingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WasmDependencyMapping not implemented")
}</span>
func (*UnimplementedQueryServer) ListWasmDependencyMapping(ctx context.Context, req *ListWasmDependencyMappingRequest) (*ListWasmDependencyMappingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListWasmDependencyMapping not implemented")
}</span>

func RegisterQueryServer(s grpc1.Server, srv QueryServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_Query_serviceDesc, srv)
}</span>

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Query/Params",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ResourceDependencyMappingFromMessageKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ResourceDependencyMappingFromMessageKeyRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ResourceDependencyMappingFromMessageKey(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Query/ResourceDependencyMappingFromMessageKey",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ResourceDependencyMappingFromMessageKey(ctx, req.(*ResourceDependencyMappingFromMessageKeyRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ListResourceDependencyMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListResourceDependencyMappingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListResourceDependencyMapping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Query/ListResourceDependencyMapping",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListResourceDependencyMapping(ctx, req.(*ListResourceDependencyMappingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_WasmDependencyMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(WasmDependencyMappingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).WasmDependencyMapping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Query/WasmDependencyMapping",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).WasmDependencyMapping(ctx, req.(*WasmDependencyMappingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Query_ListWasmDependencyMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListWasmDependencyMappingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListWasmDependencyMapping(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Query/ListWasmDependencyMapping",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServer).ListWasmDependencyMapping(ctx, req.(*ListWasmDependencyMappingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _Query_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cosmos.accesscontrol_x.v1beta1.Query",
        HandlerType: (*QueryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Params",
                        Handler:    _Query_Params_Handler,
                },
                {
                        MethodName: "ResourceDependencyMappingFromMessageKey",
                        Handler:    _Query_ResourceDependencyMappingFromMessageKey_Handler,
                },
                {
                        MethodName: "ListResourceDependencyMapping",
                        Handler:    _Query_ListResourceDependencyMapping_Handler,
                },
                {
                        MethodName: "WasmDependencyMapping",
                        Handler:    _Query_WasmDependencyMapping_Handler,
                },
                {
                        MethodName: "ListWasmDependencyMapping",
                        Handler:    _Query_ListWasmDependencyMapping_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cosmos/accesscontrol_x/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *ResourceDependencyMappingFromMessageKeyRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ResourceDependencyMappingFromMessageKeyRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ResourceDependencyMappingFromMessageKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MessageKey) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.MessageKey)
                copy(dAtA[i:], m.MessageKey)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.MessageKey)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ResourceDependencyMappingFromMessageKeyResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ResourceDependencyMappingFromMessageKeyResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ResourceDependencyMappingFromMessageKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.MessageDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *WasmDependencyMappingRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *WasmDependencyMappingRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *WasmDependencyMappingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ContractAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.ContractAddress)
                copy(dAtA[i:], m.ContractAddress)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.ContractAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *WasmDependencyMappingResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *WasmDependencyMappingResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *WasmDependencyMappingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.WasmDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *ListResourceDependencyMappingRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ListResourceDependencyMappingRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListResourceDependencyMappingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *ListResourceDependencyMappingResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ListResourceDependencyMappingResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListResourceDependencyMappingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.MessageDependencyMappingList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.MessageDependencyMappingList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.MessageDependencyMappingList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *ListWasmDependencyMappingRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ListWasmDependencyMappingRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListWasmDependencyMappingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *ListWasmDependencyMappingResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *ListWasmDependencyMappingResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *ListWasmDependencyMappingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.WasmDependencyMappingList) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.WasmDependencyMappingList) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.WasmDependencyMappingList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *ResourceDependencyMappingFromMessageKeyRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.MessageKey)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *ResourceDependencyMappingFromMessageKeyResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.MessageDependencyMapping.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *WasmDependencyMappingRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.ContractAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *WasmDependencyMappingResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.WasmDependencyMapping.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *ListResourceDependencyMappingRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *ListResourceDependencyMappingResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.MessageDependencyMappingList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.MessageDependencyMappingList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *ListWasmDependencyMappingRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *ListWasmDependencyMappingResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.WasmDependencyMappingList) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.WasmDependencyMappingList </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ResourceDependencyMappingFromMessageKeyRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ResourceDependencyMappingFromMessageKeyRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ResourceDependencyMappingFromMessageKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageKey", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MessageKey = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ResourceDependencyMappingFromMessageKeyResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ResourceDependencyMappingFromMessageKeyResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ResourceDependencyMappingFromMessageKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.MessageDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *WasmDependencyMappingRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: WasmDependencyMappingRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: WasmDependencyMappingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.ContractAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *WasmDependencyMappingResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: WasmDependencyMappingResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: WasmDependencyMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.WasmDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ListResourceDependencyMappingRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListResourceDependencyMappingRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListResourceDependencyMappingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ListResourceDependencyMappingResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListResourceDependencyMappingResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListResourceDependencyMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MessageDependencyMappingList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.MessageDependencyMappingList = append(m.MessageDependencyMappingList, accesscontrol.MessageDependencyMapping{})
                        if err := m.MessageDependencyMappingList[len(m.MessageDependencyMappingList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ListWasmDependencyMappingRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListWasmDependencyMappingRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListWasmDependencyMappingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *ListWasmDependencyMappingResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListWasmDependencyMappingResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: ListWasmDependencyMappingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMappingList", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.WasmDependencyMappingList = append(m.WasmDependencyMappingList, accesscontrol.WasmDependencyMapping{})
                        if err := m.WasmDependencyMappingList[len(m.WasmDependencyMappingList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: cosmos/accesscontrol_x/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage

func request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.Params(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_Params_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.Params(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_ResourceDependencyMappingFromMessageKey_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ResourceDependencyMappingFromMessageKeyRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["message_key"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "message_key")
        }</span>

        <span class="cov0" title="0">protoReq.MessageKey, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "message_key", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ResourceDependencyMappingFromMessageKey(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_ResourceDependencyMappingFromMessageKey_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ResourceDependencyMappingFromMessageKeyRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["message_key"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "message_key")
        }</span>

        <span class="cov0" title="0">protoReq.MessageKey, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "message_key", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ResourceDependencyMappingFromMessageKey(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_ListResourceDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListResourceDependencyMappingRequest
        var metadata runtime.ServerMetadata

        msg, err := client.ListResourceDependencyMapping(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_ListResourceDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListResourceDependencyMappingRequest
        var metadata runtime.ServerMetadata

        msg, err := server.ListResourceDependencyMapping(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Query_WasmDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq WasmDependencyMappingRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["contract_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "contract_address")
        }</span>

        <span class="cov0" title="0">protoReq.ContractAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "contract_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.WasmDependencyMapping(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Query_WasmDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq WasmDependencyMappingRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["contract_address"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "contract_address")
        }</span>

        <span class="cov0" title="0">protoReq.ContractAddress, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "contract_address", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.WasmDependencyMapping(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Query_ListWasmDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, client QueryClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListWasmDependencyMappingRequest
        var metadata runtime.ServerMetadata

        msg, err := client.ListWasmDependencyMapping(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Query_ListWasmDependencyMapping_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ListWasmDependencyMappingRequest
        var metadata runtime.ServerMetadata

        msg, err := server.ListWasmDependencyMapping(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryHandlerServer registers the http handlers for service Query to "mux".
// UnaryRPC     :call QueryServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features (such as grpc.SendHeader, etc) to stop working. Consider using RegisterQueryHandlerFromEndpoint instead.
func RegisterQueryHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_Params_0(rctx, inboundMarshaler, server, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ResourceDependencyMappingFromMessageKey_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ResourceDependencyMappingFromMessageKey_0(rctx, inboundMarshaler, server, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ResourceDependencyMappingFromMessageKey_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListResourceDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ListResourceDependencyMapping_0(rctx, inboundMarshaler, server, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListResourceDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_WasmDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_WasmDependencyMapping_0(rctx, inboundMarshaler, server, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_WasmDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListWasmDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Query_ListWasmDependencyMapping_0(rctx, inboundMarshaler, server, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListWasmDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryHandlerFromEndpoint is same as RegisterQueryHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryHandler(ctx, mux, conn)</span>
}

// RegisterQueryHandler registers the http handlers for service Query to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryHandlerClient(ctx, mux, NewQueryClient(conn))
}</span>

// RegisterQueryHandlerClient registers the http handlers for service Query
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryClient" to call the correct interceptors.
func RegisterQueryHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Query_Params_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_Params_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_Params_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ResourceDependencyMappingFromMessageKey_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ResourceDependencyMappingFromMessageKey_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ResourceDependencyMappingFromMessageKey_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListResourceDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ListResourceDependencyMapping_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListResourceDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_WasmDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_WasmDependencyMapping_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_WasmDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Query_ListWasmDependencyMapping_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Query_ListWasmDependencyMapping_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Query_ListWasmDependencyMapping_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Query_Params_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"cosmos", "cosmos-sdk", "accesscontrol", "params"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ResourceDependencyMappingFromMessageKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"cosmos", "cosmos-sdk", "accesscontrol", "resource_dependency_mapping_from_message_key", "message_key"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ListResourceDependencyMapping_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"cosmos", "cosmos-sdk", "accesscontrol", "list_resource_dependency_mapping"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_WasmDependencyMapping_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"cosmos", "cosmos-sdk", "accesscontrol", "wasm_dependency_mapping", "contract_address"}, "", runtime.AssumeColonVerbOpt(false)))

        pattern_Query_ListWasmDependencyMapping_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"cosmos", "cosmos-sdk", "accesscontrol", "list_wasm_dependency_mapping"}, "", runtime.AssumeColonVerbOpt(false)))
)

var (
        forward_Query_Params_0 = runtime.ForwardResponseMessage

        forward_Query_ResourceDependencyMappingFromMessageKey_0 = runtime.ForwardResponseMessage

        forward_Query_ListResourceDependencyMapping_0 = runtime.ForwardResponseMessage

        forward_Query_WasmDependencyMapping_0 = runtime.ForwardResponseMessage

        forward_Query_ListWasmDependencyMapping_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accesscontrol_x/tx.proto

package types

import (
        context "context"
        fmt "fmt"
        accesscontrol "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RegisterWasmDependencyJSONFile struct {
        WasmDependencyMapping accesscontrol.WasmDependencyMapping `protobuf:"bytes,1,opt,name=wasm_dependency_mapping,json=wasmDependencyMapping,proto3" json:"wasm_dependency_mapping" yaml:"wasm_dependency_mapping"`
}

func (m *RegisterWasmDependencyJSONFile) Reset()         <span class="cov0" title="0">{ *m = RegisterWasmDependencyJSONFile{} }</span>
func (m *RegisterWasmDependencyJSONFile) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RegisterWasmDependencyJSONFile) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RegisterWasmDependencyJSONFile) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a7b777fc99c34b4, []int{0}
}</span>
func (m *RegisterWasmDependencyJSONFile) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *RegisterWasmDependencyJSONFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_RegisterWasmDependencyJSONFile.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *RegisterWasmDependencyJSONFile) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RegisterWasmDependencyJSONFile.Merge(m, src)
}</span>
func (m *RegisterWasmDependencyJSONFile) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *RegisterWasmDependencyJSONFile) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RegisterWasmDependencyJSONFile.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RegisterWasmDependencyJSONFile proto.InternalMessageInfo

func (m *RegisterWasmDependencyJSONFile) GetWasmDependencyMapping() accesscontrol.WasmDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WasmDependencyMapping
        }</span>
        <span class="cov0" title="0">return accesscontrol.WasmDependencyMapping{}</span>
}

type MsgRegisterWasmDependency struct {
        FromAddress           string                              `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address" yaml:"from_address"`
        WasmDependencyMapping accesscontrol.WasmDependencyMapping `protobuf:"bytes,2,opt,name=wasm_dependency_mapping,json=wasmDependencyMapping,proto3" json:"wasm_dependency_mapping" yaml:"wasm_dependency_mapping"`
}

func (m *MsgRegisterWasmDependency) Reset()         <span class="cov0" title="0">{ *m = MsgRegisterWasmDependency{} }</span>
func (m *MsgRegisterWasmDependency) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRegisterWasmDependency) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRegisterWasmDependency) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a7b777fc99c34b4, []int{1}
}</span>
func (m *MsgRegisterWasmDependency) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRegisterWasmDependency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRegisterWasmDependency.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRegisterWasmDependency) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterWasmDependency.Merge(m, src)
}</span>
func (m *MsgRegisterWasmDependency) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRegisterWasmDependency) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterWasmDependency.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRegisterWasmDependency proto.InternalMessageInfo

func (m *MsgRegisterWasmDependency) GetFromAddress() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FromAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRegisterWasmDependency) GetWasmDependencyMapping() accesscontrol.WasmDependencyMapping <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WasmDependencyMapping
        }</span>
        <span class="cov0" title="0">return accesscontrol.WasmDependencyMapping{}</span>
}

type MsgRegisterWasmDependencyResponse struct {
}

func (m *MsgRegisterWasmDependencyResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRegisterWasmDependencyResponse{} }</span>
func (m *MsgRegisterWasmDependencyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRegisterWasmDependencyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRegisterWasmDependencyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2a7b777fc99c34b4, []int{2}
}</span>
func (m *MsgRegisterWasmDependencyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRegisterWasmDependencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRegisterWasmDependencyResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRegisterWasmDependencyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterWasmDependencyResponse.Merge(m, src)
}</span>
func (m *MsgRegisterWasmDependencyResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRegisterWasmDependencyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRegisterWasmDependencyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRegisterWasmDependencyResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*RegisterWasmDependencyJSONFile)(nil), "cosmos.accesscontrol_x.v1beta1.RegisterWasmDependencyJSONFile")
        proto.RegisterType((*MsgRegisterWasmDependency)(nil), "cosmos.accesscontrol_x.v1beta1.MsgRegisterWasmDependency")
        proto.RegisterType((*MsgRegisterWasmDependencyResponse)(nil), "cosmos.accesscontrol_x.v1beta1.MsgRegisterWasmDependencyResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("cosmos/accesscontrol_x/tx.proto", fileDescriptor_2a7b777fc99c34b4) }</span>

var fileDescriptor_2a7b777fc99c34b4 = []byte{
        // 428 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x53, 0x3d, 0x6f, 0xd4, 0x40,
        0x10, 0xf5, 0x06, 0x84, 0xc4, 0x86, 0xea, 0xf8, 0x3e, 0xa1, 0x35, 0x18, 0x04, 0x11, 0x12, 0xbb,
        0xca, 0xa5, 0x22, 0x5d, 0x4e, 0x88, 0x22, 0xe2, 0x40, 0x3a, 0x0a, 0x24, 0x9a, 0xd3, 0x9e, 0x3d,
        0x2c, 0x2b, 0xec, 0xdd, 0xc5, 0xb3, 0x21, 0xe7, 0x9a, 0x3f, 0x80, 0x84, 0x44, 0x89, 0xf8, 0x21,
        0xfc, 0x80, 0x94, 0x29, 0xa9, 0x2c, 0x74, 0xd7, 0x20, 0xca, 0xfc, 0x02, 0x14, 0xdb, 0x41, 0x5c,
        0x64, 0x5f, 0x41, 0x93, 0xca, 0x9e, 0xdd, 0xf7, 0xe6, 0xbd, 0x79, 0x9a, 0xa5, 0x61, 0x6c, 0x31,
        0xb3, 0x28, 0x64, 0x1c, 0x03, 0x62, 0x6c, 0x8d, 0xcf, 0x6d, 0x3a, 0x99, 0x09, 0x3f, 0xe3, 0x2e,
        0xb7, 0xde, 0xf6, 0x58, 0x0d, 0xe0, 0xa7, 0x00, 0xfc, 0xc3, 0xe6, 0x14, 0xbc, 0xdc, 0xec, 0x5f,
        0x51, 0x56, 0xd9, 0x0a, 0x2a, 0x8e, 0xff, 0x6a, 0x56, 0xff, 0x96, 0xb2, 0x56, 0xa5, 0x20, 0xa4,
        0xd3, 0x42, 0x1a, 0x63, 0xbd, 0xf4, 0xda, 0x1a, 0x6c, 0x6e, 0x1f, 0x36, 0xa2, 0x53, 0x89, 0x20,
        0xde, 0xef, 0x41, 0x5e, 0x88, 0xa6, 0x9d, 0x70, 0x52, 0x69, 0x53, 0x81, 0x1b, 0xec, 0x46, 0x9b,
        0xc1, 0xe5, 0xaa, 0x41, 0xde, 0xeb, 0x18, 0x45, 0x81, 0x01, 0xd4, 0x8d, 0x76, 0xf4, 0x9d, 0x50,
        0x36, 0x06, 0xa5, 0xd1, 0x43, 0xfe, 0x4a, 0x62, 0xf6, 0x04, 0x1c, 0x98, 0x04, 0x4c, 0x5c, 0xec,
        0xbe, 0x7c, 0xf1, 0xfc, 0xa9, 0x4e, 0xa1, 0xf7, 0x99, 0xd0, 0xeb, 0xfb, 0x12, 0xb3, 0x49, 0xf2,
        0xf7, 0x6e, 0x92, 0x49, 0xe7, 0xb4, 0x51, 0x37, 0xc8, 0x6d, 0xb2, 0xb1, 0x3e, 0xd8, 0xe2, 0x6d,
        0xa9, 0x9c, 0x64, 0xc2, 0x97, 0xfb, 0x8e, 0x6a, 0xea, 0xf0, 0xfe, 0x41, 0x19, 0x06, 0x47, 0x65,
        0xc8, 0x0a, 0x99, 0xa5, 0xdb, 0x51, 0x87, 0x42, 0x34, 0xbe, 0xba, 0xdf, 0x46, 0xdf, 0x3e, 0xff,
        0xeb, 0x5b, 0x18, 0x44, 0x1f, 0xd7, 0xe8, 0xcd, 0x11, 0xaa, 0xf6, 0x09, 0x7a, 0xbb, 0xf4, 0xd2,
        0x9b, 0xdc, 0x66, 0x13, 0x99, 0x24, 0x39, 0x20, 0x56, 0x6e, 0x2f, 0x0e, 0x1f, 0xfc, 0x2e, 0xc3,
        0xa5, 0xf3, 0xa3, 0x32, 0xbc, 0x5c, 0x9b, 0xf8, 0xf7, 0x34, 0x1a, 0xaf, 0x1f, 0x97, 0x3b, 0x75,
        0xb5, 0x32, 0x85, 0xb5, 0x33, 0x4e, 0xe1, 0x2e, 0xbd, 0xd3, 0x19, 0xc2, 0x18, 0xd0, 0x59, 0x83,
        0x30, 0xf8, 0x4a, 0xe8, 0xb9, 0x11, 0xaa, 0xde, 0x17, 0x42, 0xaf, 0x75, 0xe4, 0xf5, 0x98, 0xaf,
        0xde, 0x6e, 0xde, 0xa9, 0xd2, 0xdf, 0xf9, 0x6f, 0xea, 0x89, 0xc1, 0xe1, 0xb3, 0x83, 0x39, 0x23,
        0x87, 0x73, 0x46, 0x7e, 0xce, 0x19, 0xf9, 0xb4, 0x60, 0xc1, 0xe1, 0x82, 0x05, 0x3f, 0x16, 0x2c,
        0x78, 0x3d, 0x50, 0xda, 0xbf, 0xdd, 0x9b, 0xf2, 0xd8, 0x66, 0xa2, 0xd9, 0xea, 0xfa, 0xf3, 0x08,
        0x93, 0x77, 0x62, 0x76, 0xea, 0x31, 0xf8, 0xc2, 0x01, 0x4e, 0x2f, 0x54, 0xfb, 0xbd, 0xf5, 0x27,
        0x00, 0x00, 0xff, 0xff, 0x45, 0x4d, 0x76, 0xee, 0xd2, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
        RegisterWasmDependency(ctx context.Context, in *MsgRegisterWasmDependency, opts ...grpc.CallOption) (*MsgRegisterWasmDependencyResponse, error)
}

type msgClient struct {
        cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient <span class="cov0" title="0">{
        return &amp;msgClient{cc}
}</span>

func (c *msgClient) RegisterWasmDependency(ctx context.Context, in *MsgRegisterWasmDependency, opts ...grpc.CallOption) (*MsgRegisterWasmDependencyResponse, error) <span class="cov0" title="0">{
        out := new(MsgRegisterWasmDependencyResponse)
        err := c.cc.Invoke(ctx, "/cosmos.accesscontrol_x.v1beta1.Msg/RegisterWasmDependency", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
        RegisterWasmDependency(context.Context, *MsgRegisterWasmDependency) (*MsgRegisterWasmDependencyResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterWasmDependency(ctx context.Context, req *MsgRegisterWasmDependency) (*MsgRegisterWasmDependencyResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RegisterWasmDependency not implemented")
}</span>

func RegisterMsgServer(s grpc1.Server, srv MsgServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;_Msg_serviceDesc, srv)
}</span>

func _Msg_RegisterWasmDependency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(MsgRegisterWasmDependency)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServer).RegisterWasmDependency(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/cosmos.accesscontrol_x.v1beta1.Msg/RegisterWasmDependency",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServer).RegisterWasmDependency(ctx, req.(*MsgRegisterWasmDependency))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

var _Msg_serviceDesc = grpc.ServiceDesc{
        ServiceName: "cosmos.accesscontrol_x.v1beta1.Msg",
        HandlerType: (*MsgServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RegisterWasmDependency",
                        Handler:    _Msg_RegisterWasmDependency_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "cosmos/accesscontrol_x/tx.proto",
}

func (m *RegisterWasmDependencyJSONFile) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *RegisterWasmDependencyJSONFile) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *RegisterWasmDependencyJSONFile) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.WasmDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *MsgRegisterWasmDependency) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRegisterWasmDependency) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRegisterWasmDependency) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.WasmDependencyMapping.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintTx(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.FromAddress) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.FromAddress)
                copy(dAtA[i:], m.FromAddress)
                i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRegisterWasmDependencyResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRegisterWasmDependencyResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRegisterWasmDependencyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintTx(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovTx(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *RegisterWasmDependencyJSONFile) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.WasmDependencyMapping.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgRegisterWasmDependency) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.FromAddress)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovTx(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.WasmDependencyMapping.Size()
        n += 1 + l + sovTx(uint64(l))
        return n</span>
}

func (m *MsgRegisterWasmDependencyResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovTx(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozTx(x uint64) (n int) <span class="cov0" title="0">{
        return sovTx(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *RegisterWasmDependencyJSONFile) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegisterWasmDependencyJSONFile: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: RegisterWasmDependencyJSONFile: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.WasmDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRegisterWasmDependency) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterWasmDependency: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterWasmDependency: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.FromAddress = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field WasmDependencyMapping", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.WasmDependencyMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRegisterWasmDependencyResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterWasmDependencyResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRegisterWasmDependencyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipTx(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipTx(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowTx
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowTx
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthTx
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupTx
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthTx
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file21" style="display: none">package types

import (
        "encoding/json"
        "fmt"

        acltypes "github.com/cosmos/cosmos-sdk/types/accesscontrol"
        "github.com/savaki/jq"
)

type WasmMessageInfo struct {
        MessageType     acltypes.WasmMessageSubtype
        MessageName     string
        MessageBody     []byte
        MessageFullBody []byte
}

func NewExecuteMessageInfo(fullBody []byte) (*WasmMessageInfo, error) <span class="cov8" title="1">{
        return newMessageInfo(fullBody, acltypes.WasmMessageSubtype_EXECUTE)
}</span>

func NewQueryMessageInfo(fullBody []byte) (*WasmMessageInfo, error) <span class="cov0" title="0">{
        return newMessageInfo(fullBody, acltypes.WasmMessageSubtype_QUERY)
}</span>

func newMessageInfo(fullBody []byte, messageType acltypes.WasmMessageSubtype) (*WasmMessageInfo, error) <span class="cov8" title="1">{
        name, body, err := extractMessage(fullBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;WasmMessageInfo{
                MessageType:     messageType,
                MessageName:     name,
                MessageBody:     body,
                MessageFullBody: fullBody,
        }, nil</span>
}

// WASM message body is JSON-serialized and use the message name
// as the only top-level key
func extractMessage(fullBody []byte) (string, []byte, error) <span class="cov8" title="1">{
        var deserialized map[string]json.RawMessage
        if err := json.Unmarshal(fullBody, &amp;deserialized); err != nil </span><span class="cov8" title="1">{
                return "", fullBody, err
        }</span>
        <span class="cov8" title="1">topLevelKeys := []string{}
        for k := range deserialized </span><span class="cov8" title="1">{
                topLevelKeys = append(topLevelKeys, k)
        }</span>
        <span class="cov8" title="1">if len(topLevelKeys) != 1 </span><span class="cov8" title="1">{
                return "", fullBody, fmt.Errorf("expected exactly one top-level key but found %s", topLevelKeys)
        }</span>
        <span class="cov8" title="1">return topLevelKeys[0], deserialized[topLevelKeys[0]], nil</span>
}

type WasmMessageTranslator struct {
        originalSender          string
        originalContractAddress string
        originalMsgInfo         *WasmMessageInfo
}

func NewWasmMessageTranslator(sender, contractAddress string, msgInfo *WasmMessageInfo) WasmMessageTranslator <span class="cov8" title="1">{
        return WasmMessageTranslator{
                originalSender:          sender,
                originalContractAddress: contractAddress,
                originalMsgInfo:         msgInfo,
        }
}</span>

// This function takes in a a translation template formatted as a JSON body and stored as part of a wasm dependency mapping,
// and then applies the JQ style patterns to fill in the template with the appropriate values
// There are some reserved keywords for the template for string values such as sender or contract address for the new JSON message body
//
// "_sender": This is used to fill in the sender for the previous wasm message
//
// "_contract_address": This is used to fill in the contract address for the previous wasm message
//
// "__": This is used to prefix a value literal. eg. "__someValue" -&gt; "someValue"
func (translator WasmMessageTranslator) TranslateMessageBody(translationTemplate []byte) ([]byte, error) <span class="cov8" title="1">{
        jsonTemplate := map[string]interface{}{}
        // parse JSON template map from the bytes
        err := json.Unmarshal(translationTemplate, &amp;jsonTemplate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">translatedMsgBody := translator.translateMap(jsonTemplate)
        return json.Marshal(translatedMsgBody)</span>
}

func (translator WasmMessageTranslator) translateMap(aMap map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        translatedMap := map[string]interface{}{}
        for key, val := range aMap </span><span class="cov8" title="1">{
                switch concreteVal := val.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        translatedMap[key] = translator.translateMap(concreteVal)</span>
                case []interface{}:<span class="cov8" title="1">
                        translatedMap[key] = translator.translateArray(concreteVal)</span>
                case string:<span class="cov8" title="1">
                        translatedString, err := translator.translateValue(concreteVal)
                        if err != nil </span><span class="cov8" title="1">{
                                // TODO: how should we handle this? likely incorrectly formatted, I think we should drop so the selectors are evaluated conservatively
                                continue</span>
                        }
                        <span class="cov8" title="1">translatedMap[key] = translatedString</span>
                default:<span class="cov8" title="1">
                        translatedMap[key] = concreteVal</span>
                }
        }
        <span class="cov8" title="1">return translatedMap</span>
}

func (translator WasmMessageTranslator) translateArray(anArray []interface{}) []interface{} <span class="cov8" title="1">{
        translatedArray := []interface{}{}
        for _, val := range anArray </span><span class="cov8" title="1">{
                switch concreteVal := val.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        translatedArray = append(translatedArray, translator.translateMap(concreteVal))</span>
                case []interface{}:<span class="cov8" title="1">
                        translatedArray = append(translatedArray, translator.translateArray(concreteVal))</span>
                case string:<span class="cov8" title="1">
                        translatedString, err := translator.translateValue(concreteVal)
                        if err != nil </span><span class="cov0" title="0">{
                                // TODO: how should we handle this? likely incorrectly formatted, I think we should drop so the selectors are evaluated conservatively
                                continue</span>
                        }
                        <span class="cov8" title="1">translatedArray = append(translatedArray, translatedString)</span>
                default:<span class="cov0" title="0">
                        translatedArray = append(translatedArray, concreteVal)</span>
                }
        }
        <span class="cov8" title="1">return translatedArray</span>
}

func (translator WasmMessageTranslator) translateValue(stringVal string) (interface{}, error) <span class="cov8" title="1">{
        const reservedSender = "_sender"
        const reservedContractAddr = "_contract_address"
        const literalPrefix = "__"
        var newVal interface{}
        if stringVal == reservedSender </span><span class="cov8" title="1">{
                newVal = translator.originalSender
        }</span> else<span class="cov8" title="1"> if stringVal == reservedContractAddr </span><span class="cov8" title="1">{
                newVal = translator.originalContractAddress
        }</span> else<span class="cov8" title="1"> if len(stringVal) &gt; 2 &amp;&amp; stringVal[:2] == literalPrefix </span><span class="cov8" title="1">{
                // fill in the literal without the prefix
                newVal = stringVal[2:]
        }</span> else<span class="cov8" title="1"> {
                // parse the jq instruction from the template
                op, err := jq.Parse(stringVal)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // retrieve the appropriate item from the original msg
                <span class="cov8" title="1">data, err := op.Apply(translator.originalMsgInfo.MessageFullBody)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">newVal = json.RawMessage(data)</span>
        }
        <span class="cov8" title="1">return newVal, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
